import {
  MenuItemEl,
  styles as styles3,
  styles2 as styles4
} from "./chunk-53HEJ6S2.js";
import {
  CLOSE_REASON,
  KEYDOWN_CLOSE_KEYS,
  NAVIGABLE_KEY,
  SELECTION_KEY,
  createActivateTypeaheadEvent,
  createCloseOnFocusoutEvent,
  createDeactivateItemsEvent,
  createDeactivateTypeaheadEvent,
  createStayOpenOnFocusoutEvent
} from "./chunk-HDLF6MIZ.js";
import {
  List
} from "./chunk-JFJHWGBI.js";
import {
  styles,
  styles2
} from "./chunk-A7TLSAJF.js";
import "./chunk-QMWFSKRU.js";
import "./chunk-KNQF55TS.js";
import "./chunk-NEIZMGXN.js";
import "./chunk-2ZSYHBR4.js";
import "./chunk-G7CEFHTH.js";
import "./chunk-XGPSJZLU.js";
import "./chunk-4UGJ6ES7.js";
import {
  __decorate,
  customElement,
  html,
  property,
  queryAssignedElements,
  state
} from "./chunk-DO6UFQ5V.js";

// node_modules/@material/web/menu/internal/submenuitem/sub-menu-item.js
function stopPropagation(event) {
  event.stopPropagation();
}
var SubMenuItem = class extends MenuItemEl {
  constructor() {
    super(...arguments);
    this.anchorCorner = "START_END";
    this.menuCorner = "START_START";
    this.hoverOpenDelay = 400;
    this.hoverCloseDelay = 400;
    this.selected = false;
    this.submenuHover = false;
    this.keepOpenOnClick = true;
    this.previousOpenTimeout = 0;
    this.previousCloseTimeout = 0;
    this.onPointerenter = () => {
      var _a;
      clearTimeout(this.previousOpenTimeout);
      clearTimeout(this.previousCloseTimeout);
      if ((_a = this.submenuEl) == null ? void 0 : _a.open)
        return;
      if (!this.hoverOpenDelay) {
        this.show();
      } else {
        this.previousOpenTimeout = setTimeout(() => {
          this.show();
        }, this.hoverOpenDelay);
      }
    };
    this.onPointerleave = () => {
      clearTimeout(this.previousCloseTimeout);
      clearTimeout(this.previousOpenTimeout);
      if (!this.hoverCloseDelay) {
        this.close();
      } else {
        this.previousCloseTimeout = setTimeout(() => {
          this.close();
        }, this.hoverCloseDelay);
      }
    };
  }
  get submenuEl() {
    return this.menus[0];
  }
  onClick() {
    this.show();
  }
  getRenderClasses() {
    return { ...super.getRenderClasses(), "submenu-hover": this.submenuHover };
  }
  /**
   * On item keydown handles opening the submenu.
   */
  onKeydown(event) {
    const shouldOpenSubmenu = this.isSubmenuOpenKey(event.code);
    if (event.code === SELECTION_KEY.SPACE) {
      event.preventDefault();
    }
    if (!shouldOpenSubmenu) {
      super.onKeydown(event);
      return;
    }
    const submenu = this.submenuEl;
    if (!submenu)
      return;
    const submenuItems = submenu.items;
    const firstActivatableItem = List.getFirstActivatableItem(submenuItems);
    if (firstActivatableItem) {
      this.show(() => {
        firstActivatableItem.active = true;
      });
      return;
    }
  }
  /**
   * Render the submenu at the end
   */
  renderEnd() {
    return html`${super.renderEnd()}${this.renderSubMenu()}`;
  }
  /**
   * Renders the slot for the submenu.
   */
  renderSubMenu() {
    return html`<span class="submenu"><slot
        name="submenu"
        @pointerenter=${this.onSubmenuPointerEnter}
        @pointerleave=${this.onSubmenuPointerLeave}
        @pointerdown=${stopPropagation}
        @click=${stopPropagation}
        @keydown=${this.onSubMenuKeydown}
        @close-menu=${this.onCloseSubmenu}
    ></slot></span>`;
  }
  onCloseSubmenu(event) {
    var _a;
    const { itemPath, reason } = event.detail;
    itemPath.push(this);
    this.dispatchEvent(createCloseOnFocusoutEvent());
    this.dispatchEvent(createActivateTypeaheadEvent());
    if (reason.kind === CLOSE_REASON.KEYDOWN && reason.key === KEYDOWN_CLOSE_KEYS.ESCAPE) {
      event.stopPropagation();
      this.active = true;
      this.selected = false;
      (_a = this.listItemRoot) == null ? void 0 : _a.focus();
      return;
    }
    this.active = false;
    this.selected = false;
  }
  async onSubMenuKeydown(event) {
    event.stopPropagation();
    const shouldClose = this.isSubmenuCloseKey(event.code);
    if (!shouldClose)
      return;
    this.close(() => {
      var _a;
      List.deactivateActiveItem(this.submenuEl.items);
      (_a = this.listItemRoot) == null ? void 0 : _a.focus();
      this.active = true;
    });
  }
  /**
   * Shows the submenu.
   *
   * @param onOpened A function to call after the menu is opened.
   */
  show(onOpened = () => {
  }) {
    const menu = this.submenuEl;
    if (!menu)
      return;
    menu.quick = true;
    menu.hasOverflow = true;
    menu.anchorCorner = this.anchorCorner;
    menu.menuCorner = this.menuCorner;
    menu.anchor = this;
    menu.defaultFocus = "LIST_ROOT";
    menu.skipRestoreFocus = true;
    menu.stayOpenOnOutsideClick = true;
    menu.stayOpenOnFocusout = true;
    const menuAlreadyOpen = menu.open;
    this.dispatchEvent(createStayOpenOnFocusoutEvent());
    menu.show();
    this.dispatchEvent(createDeactivateItemsEvent());
    this.dispatchEvent(createDeactivateTypeaheadEvent());
    this.selected = true;
    if (menuAlreadyOpen) {
      onOpened();
    } else {
      menu.addEventListener("opened", onOpened, { once: true });
    }
  }
  /**
   * Closes the submenu.
   *
   * @param onClosed A function to call after the menu is closed.
   */
  close(onClosed = () => {
  }) {
    const menu = this.submenuEl;
    if (!menu || !menu.open)
      return;
    this.dispatchEvent(createActivateTypeaheadEvent());
    menu.quick = true;
    menu.close();
    this.dispatchEvent(createCloseOnFocusoutEvent());
    this.active = false;
    this.selected = false;
    menu.addEventListener("closed", onClosed, { once: true });
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should open
   * the submenu. This is RTL-aware. By default, left, right, space, or enter.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should open the submenu.
   */
  isSubmenuOpenKey(code) {
    const isRtl = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl ? NAVIGABLE_KEY.LEFT : NAVIGABLE_KEY.RIGHT;
    switch (code) {
      case arrowEnterKey:
      case SELECTION_KEY.SPACE:
      case SELECTION_KEY.ENTER:
        return true;
      default:
        return false;
    }
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should close
   * the submenu. This is RTL-aware. By default right, left, or escape.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should close the submenu.
   */
  isSubmenuCloseKey(code) {
    const isRtl = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl ? NAVIGABLE_KEY.RIGHT : NAVIGABLE_KEY.LEFT;
    switch (code) {
      case arrowEnterKey:
      case KEYDOWN_CLOSE_KEYS.ESCAPE:
        return true;
      default:
        return false;
    }
  }
  onSubmenuPointerEnter() {
    this.submenuHover = true;
  }
  onSubmenuPointerLeave() {
    this.submenuHover = false;
  }
};
__decorate([
  property({ attribute: "anchor-corner" })
], SubMenuItem.prototype, "anchorCorner", void 0);
__decorate([
  property({ attribute: "menu-corner" })
], SubMenuItem.prototype, "menuCorner", void 0);
__decorate([
  property({ type: Number, attribute: "hover-open-delay" })
], SubMenuItem.prototype, "hoverOpenDelay", void 0);
__decorate([
  property({ type: Number, attribute: "hover-close-delay" })
], SubMenuItem.prototype, "hoverCloseDelay", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], SubMenuItem.prototype, "selected", void 0);
__decorate([
  state()
], SubMenuItem.prototype, "submenuHover", void 0);
__decorate([
  queryAssignedElements({ slot: "submenu", flatten: true })
], SubMenuItem.prototype, "menus", void 0);

// node_modules/@material/web/menu/sub-menu-item.js
var MdSubMenuItem = class MdSubMenuItem2 extends SubMenuItem {
};
MdSubMenuItem.styles = [styles2, styles4, styles, styles3];
MdSubMenuItem = __decorate([
  customElement("md-sub-menu-item")
], MdSubMenuItem);
export {
  MdSubMenuItem
};
/*! Bundled license information:

@material/web/menu/internal/submenuitem/sub-menu-item.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/web/menu/sub-menu-item.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@material_web_menu_sub-menu-item.js.map
