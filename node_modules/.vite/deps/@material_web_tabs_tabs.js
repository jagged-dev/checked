import {
  MdTab
} from "./chunk-J2FLXW4Z.js";
import "./chunk-MAIEDRNT.js";
import "./chunk-P6K6KJ5M.js";
import "./chunk-TZGAGXFH.js";
import "./chunk-JPR3FIKU.js";
import "./chunk-2ZSYHBR4.js";
import "./chunk-4UQ5ADZQ.js";
import "./chunk-4UGJ6ES7.js";
import "./chunk-7N625B2X.js";
import {
  LitElement,
  __decorate,
  css,
  customElement,
  html,
  isServer,
  property,
  queryAssignedElements,
  state
} from "./chunk-DO6UFQ5V.js";

// node_modules/@material/web/tabs/internal/tabs.js
var NAVIGATION_KEYS = /* @__PURE__ */ new Map([
  ["default", /* @__PURE__ */ new Set(["Home", "End"])],
  ["horizontal", /* @__PURE__ */ new Set(["ArrowLeft", "ArrowRight"])],
  ["vertical", /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown"])]
]);
var Tabs = class extends LitElement {
  /**
   * The item currently selected.
   */
  get selectedItem() {
    return this.items[this.selected];
  }
  /**
   * The item previously selected.
   */
  get previousSelectedItem() {
    return this.items[this.previousSelected];
  }
  /**
   * The item currently focused.
   */
  get focusedItem() {
    return this.items.find((el) => el.matches(":focus-within"));
  }
  constructor() {
    super();
    this.variant = "primary";
    this.disabled = false;
    this.selected = 0;
    this.selectOnFocus = false;
    this.previousSelected = -1;
    this.orientation = "horizontal";
    this.scrollMargin = 48;
    this.itemsDirty = false;
    this.selectedAttribute = `selected`;
    this.handleKeydown = async (event) => {
      const { key } = event;
      const shouldHandleKey = NAVIGATION_KEYS.get("default").has(key) || NAVIGATION_KEYS.get(this.orientation).has(key);
      if (!shouldHandleKey || await this.wasEventPrevented(event, true) || this.disabled) {
        return;
      }
      let indexToFocus = -1;
      const focused = this.focusedItem ?? this.selectedItem;
      const itemCount = this.items.length;
      const isPrevKey = key === "ArrowLeft" || key === "ArrowUp";
      if (key === "Home") {
        indexToFocus = 0;
      } else if (key === "End") {
        indexToFocus = itemCount - 1;
      } else {
        const focusedIndex = this.items.indexOf(focused) || 0;
        indexToFocus = focusedIndex + (isPrevKey ? -1 : 1);
        indexToFocus = indexToFocus < 0 ? itemCount - 1 : indexToFocus % itemCount;
      }
      const itemToFocus = this.findFocusableItem(indexToFocus, key === "End" || isPrevKey);
      indexToFocus = this.items.indexOf(itemToFocus);
      if (itemToFocus !== null && itemToFocus !== focused) {
        this.updateFocusableItem(itemToFocus);
        itemToFocus.focus();
        if (this.selectOnFocus) {
          this.selected = indexToFocus;
          await this.dispatchInteraction();
        }
      }
    };
    this.handleKeyup = () => {
      this.scrollItemIntoView(this.focusedItem ?? this.selectedItem);
    };
    this.handleFocusout = async () => {
      await this.updateComplete;
      const nowFocused = this.getRootNode().activeElement;
      if (this.items.indexOf(nowFocused) === -1) {
        this.updateFocusableItem(this.selectedItem);
      }
    };
    if (!isServer) {
      this.addEventListener("keydown", this.handleKeydown);
      this.addEventListener("keyup", this.handleKeyup);
      this.addEventListener("focusout", this.handleFocusout);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "tablist");
  }
  findFocusableItem(i = -1, prev = false, tries = 0) {
    var _a;
    const itemCount = this.items.length - 1;
    while (((_a = this.items[i]) == null ? void 0 : _a.disabled) && tries <= itemCount) {
      tries++;
      i = i + (prev ? -1 : 1);
      if (i > itemCount) {
        return this.findFocusableItem(0, false, tries);
      } else if (i < 0) {
        return this.findFocusableItem(itemCount, true, tries);
      }
    }
    return this.items[i] ?? null;
  }
  // Note, this is async to allow the event to bubble to user code, which
  // may call `preventDefault`. If it does, avoid performing the tabs action
  // which is selecting a new tab. Sometimes, the native event must be
  // prevented to avoid, for example, scrolling. In this case, the event is
  // patched to be able to detect if the user calls prevent default.
  // Alternatively, the event could be stopped and re-dispatched synchroously,
  // but this would be complicated since the event should be re-dispatched from
  // the initial element to potentially trigger a native action (e.g. a history
  // navigation via a tab label), and this could result in some listener hearing
  // 2x events.
  async wasEventPrevented(event, preventNativeDefault = false) {
    if (preventNativeDefault) {
      event.preventDefault();
      Object.defineProperties(event, {
        "defaultPrevented": { value: false, writable: true, configurable: true },
        "preventDefault": {
          // Type needed for closure conformance. Using the Event type results
          // in a type error.
          value() {
            this.defaultPrevented = true;
          },
          writable: true,
          configurable: true
        }
      });
    }
    await new Promise(requestAnimationFrame);
    return event.defaultPrevented;
  }
  async dispatchInteraction() {
    await new Promise(requestAnimationFrame);
    const event = new Event("change", { bubbles: true });
    this.dispatchEvent(event);
  }
  willUpdate(changed) {
    if (changed.has("selected")) {
      this.previousSelected = changed.get("selected") ?? -1;
    }
    if (changed.has("variant")) {
      this.orientation = this.variant.includes("vertical") ? "vertical" : "horizontal";
    }
    if (this.itemsDirty) {
      this.itemsDirty = false;
      this.previousSelected = -1;
    }
  }
  async updated(changed) {
    var _a, _b;
    const itemsOrVariantChanged = changed.has("itemsDirty") || changed.has("variant");
    if (itemsOrVariantChanged || changed.has("disabled")) {
      this.items.forEach((item, i) => {
        item.selected = this.selected === i;
        item.variant = this.variant;
        item.disabled = this.disabled;
      });
    }
    if (itemsOrVariantChanged || changed.has("selected")) {
      if (this.previousSelectedItem !== this.selectedItem) {
        (_a = this.previousSelectedItem) == null ? void 0 : _a.removeAttribute(this.selectedAttribute);
        (_b = this.selectedItem) == null ? void 0 : _b.setAttribute(this.selectedAttribute, "");
      }
      if (this.selectedItem !== this.focusedItem) {
        this.updateFocusableItem(this.selectedItem);
      }
      await this.scrollItemIntoView();
    }
  }
  updateFocusableItem(focusableItem) {
    for (const item of this.items) {
      item.focusable = item === focusableItem;
    }
  }
  render() {
    return html`
      <slot @slotchange=${this.handleSlotChange} @click=${this.handleItemClick}></slot>
    `;
  }
  async handleItemClick(event) {
    const { target } = event;
    if (await this.wasEventPrevented(event)) {
      return;
    }
    const item = target.closest(`${this.localName} > *`);
    const i = this.items.indexOf(item);
    if (i > -1 && this.selected !== i) {
      this.selected = i;
      this.updateFocusableItem(this.selectedItem);
      await this.dispatchInteraction();
    }
  }
  handleSlotChange() {
    this.itemsDirty = true;
  }
  async itemsUpdateComplete() {
    for (const item of this.items) {
      await item.updateComplete;
    }
    return true;
  }
  // ensures the given item is visible in view; defaults to the selected item
  async scrollItemIntoView(item = this.selectedItem) {
    if (!item) {
      return;
    }
    await this.itemsUpdateComplete();
    const isVertical = this.orientation === "vertical";
    const offset = isVertical ? item.offsetTop : item.offsetLeft;
    const extent = isVertical ? item.offsetHeight : item.offsetWidth;
    const scroll = isVertical ? this.scrollTop : this.scrollLeft;
    const hostExtent = isVertical ? this.offsetHeight : this.offsetWidth;
    const min = offset - this.scrollMargin;
    const max = offset + extent - hostExtent + this.scrollMargin;
    const to = Math.min(min, Math.max(max, scroll));
    const behavior = (
      // type annotation because `instant` is valid but not included in type.
      this.focusedItem !== void 0 ? "smooth" : "instant"
    );
    this.scrollTo({
      behavior,
      [isVertical ? "left" : "top"]: 0,
      [isVertical ? "top" : "left"]: to
    });
  }
};
Tabs.shadowRootOptions = {
  ...LitElement.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  property({ reflect: true })
], Tabs.prototype, "variant", void 0);
__decorate([
  property({ type: Boolean })
], Tabs.prototype, "disabled", void 0);
__decorate([
  property({ type: Number })
], Tabs.prototype, "selected", void 0);
__decorate([
  property({ type: Boolean, attribute: "select-on-focus" })
], Tabs.prototype, "selectOnFocus", void 0);
__decorate([
  queryAssignedElements({ selector: "md-tab", flatten: true })
], Tabs.prototype, "items", void 0);
__decorate([
  state()
], Tabs.prototype, "itemsDirty", void 0);

// node_modules/@material/web/tabs/internal/tabs-styles.css.js
var styles = css`:host{box-sizing:border-box;display:flex;justify-content:space-between;align-items:end;overflow:auto;scroll-behavior:smooth;scrollbar-width:none;position:relative}:host([hidden]){display:none}:host([variant~=vertical]:not([hidden])){display:inline-flex;flex-direction:column;align-items:stretch;gap:0px}:host::-webkit-scrollbar{display:none}::slotted(*){flex:1}::slotted([selected]){z-index:1}/*# sourceMappingURL=tabs-styles.css.map */
`;

// node_modules/@material/web/tabs/tabs.js
var MdTabs = class MdTabs2 extends Tabs {
};
MdTabs.styles = [styles];
MdTabs = __decorate([
  customElement("md-tabs")
], MdTabs);
export {
  MdTab,
  MdTabs
};
/*! Bundled license information:

@material/web/tabs/internal/tabs.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/web/tabs/internal/tabs-styles.css.js:
  (**
    * @license
    * Copyright 2022 Google LLC
    * SPDX-License-Identifier: Apache-2.0
    *)

@material/web/tabs/tabs.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@material_web_tabs_tabs.js.map
