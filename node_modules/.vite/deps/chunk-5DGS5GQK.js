import {
  getSelectedItems
} from "./chunk-ALOGKB5M.js";
import {
  DEFAULT_TYPEAHEAD_BUFFER_TIME,
  TYPEAHEAD_RECORD
} from "./chunk-USIVYXCA.js";
import {
  List
} from "./chunk-IIXBCQT4.js";
import {
  isElementInSubtree,
  isSelectableKey
} from "./chunk-V3MR2ZD3.js";
import {
  html as html2
} from "./chunk-QMWFSKRU.js";
import {
  classMap
} from "./chunk-4UGJ6ES7.js";
import {
  LitElement,
  __decorate,
  css,
  html,
  property,
  query,
  queryAssignedElements,
  state
} from "./chunk-DO6UFQ5V.js";

// node_modules/@material/web/select/internal/shared-styles.css.js
var styles = css`:host{color:unset;min-width:210px}.field{cursor:default;outline:none}.select{position:relative}.field,.select,md-menu{min-width:inherit;width:inherit;max-width:inherit}.field,.select{width:100%}:host{display:inline-flex}:host([disabled]){pointer-events:none}/*# sourceMappingURL=shared-styles.css.map */
`;

// node_modules/@material/web/select/internal/select.js
var _a;
var VALUE = Symbol("value");
var Select = class extends LitElement {
  constructor() {
    super(...arguments);
    this.quick = false;
    this.required = false;
    this.disabled = false;
    this.errorText = "";
    this.label = "";
    this.supportingText = "";
    this.error = false;
    this.menuFixed = false;
    this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
    this.hasLeadingIcon = false;
    this.hasTrailingIcon = false;
    this.displayText = "";
    this.focused = false;
    this.open = false;
    this[_a] = "";
    this.lastUserSetValue = null;
    this.lastUserSetSelectedIndex = null;
    this.lastSelectedOption = null;
    this.lastSelectedOptionRecords = [];
  }
  /**
   * The value of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `value` setting `value` will incur a DOM query.
   */
  get value() {
    return this[VALUE];
  }
  set value(value) {
    this.lastUserSetValue = value;
    this.select(value);
  }
  get options() {
    var _a2;
    return ((_a2 = this.menu) == null ? void 0 : _a2.items) ?? [];
  }
  /**
   * The index of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `selectedIndex` setting `selectedIndex` will incur a
   * DOM query.
   */
  get selectedIndex() {
    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];
    return index ?? -1;
  }
  set selectedIndex(index) {
    this.lastUserSetSelectedIndex = index;
    this.selectIndex(index);
  }
  /**
   * Returns an array of selected options.
   *
   * NOTE: md-select only suppoprts single selection.
   */
  get selectedOptions() {
    return (this.getSelectedOptions() ?? []).map(([option]) => option);
  }
  render() {
    return html`
      <span
          class="select ${classMap(this.getRenderClasses())}"
          @focusout=${this.handleFocusout}>
        ${this.renderField()}
        ${this.renderMenu()}
      </span>
    `;
  }
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "error": this.error
    };
  }
  renderField() {
    return html2`
      <${this.fieldTag}
          aria-haspopup="listbox"
          role="combobox"
          part="field"
          tabindex=${this.disabled ? "-1" : "0"}
          aria-expanded=${this.open ? "true" : "false"}
          class="field"
          label=${this.label}
          .focused=${this.focused || this.open}
          .populated=${!!this.displayText}
          .disabled=${this.disabled}
          .required=${this.required}
          .error=${this.error}
          .hasStart=${this.hasLeadingIcon}
          .hasEnd=${this.hasTrailingIcon}
          supporting-text=${this.supportingText}
          error-text=${this.errorText}
          @keydown =${this.handleKeydown}
          @click=${this.handleClick}
          @focus=${this.handleFocus}
          @blur=${this.handleBlur}>
        ${this.renderFieldContent()}
      </${this.fieldTag}>`;
  }
  renderFieldContent() {
    return [
      this.renderLeadingIcon(),
      this.renderLabel(),
      this.renderTrailingIcon()
    ];
  }
  renderLeadingIcon() {
    return html`
      <span class="icon leading" slot="start">
         <slot name="leadingicon" @slotchange=${this.handleIconChange}></slot>
      </span>
     `;
  }
  renderTrailingIcon() {
    return html`
      <span class="icon trailing" slot="end">
         <slot name="trailingicon" @slotchange=${this.handleIconChange}></slot>
      </span>
     `;
  }
  renderLabel() {
    return html`<div id="label">${this.displayText || html`&nbsp;`}</div>`;
  }
  renderMenu() {
    return html`
      <md-menu
          id="listbox"
          default-focus="NONE"
          listTabIndex="-1"
          type="listbox"
          stay-open-on-focusout
          part="menu"
          exportparts="focus-ring: menu-focus-ring"
          .anchor=${this.field}
          .open=${this.open}
          .quick=${this.quick}
          .fixed=${this.menuFixed}
          .typeaheadDelay=${this.typeaheadDelay}
          @opening=${this.handleOpening}
          @closing=${this.handleClosing}
          @close-menu=${this.handleCloseMenu}
          @request-selection=${this.handleRequestSelection}
          @request-deselection=${this.handleRequestDeselection}>
        ${this.renderMenuContent()}
      </md-menu>`;
  }
  renderMenuContent() {
    return html`<slot></slot>`;
  }
  /**
   * Handles opening the select on keydown and typahead selection when the menu
   * is closed.
   */
  handleKeydown(event) {
    if (this.open || this.disabled || !this.menu) {
      return;
    }
    const typeaheadController = this.menu.typeaheadController;
    const isOpenKey = event.code === "Space" || event.code === "ArrowDown" || event.code === "Enter";
    if (!typeaheadController.isTypingAhead && isOpenKey) {
      event.preventDefault();
      this.open = true;
      return;
    }
    const isPrintableKey = event.key.length === 1;
    if (isPrintableKey) {
      typeaheadController.onKeydown(event);
      event.preventDefault();
      const { lastActiveRecord } = typeaheadController;
      if (!lastActiveRecord) {
        return;
      }
      const hasChanged = this.selectItem(lastActiveRecord[TYPEAHEAD_RECORD.ITEM]);
      if (hasChanged) {
        this.dispatchInteractionEvents();
      }
    }
  }
  handleClick() {
    this.open = true;
  }
  handleFocus() {
    this.focused = true;
  }
  handleBlur() {
    this.focused = false;
  }
  /**
   * Handles closing the menu when the focus leaves the select's subtree.
   */
  handleFocusout(event) {
    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {
      return;
    }
    this.open = false;
  }
  /**
   * Gets a list of all selected select options as a list item record array.
   *
   * @return An array of selected list option records.
   */
  getSelectedOptions() {
    if (!this.menu) {
      this.lastSelectedOptionRecords = [];
      return null;
    }
    const items = this.menu.items;
    this.lastSelectedOptionRecords = getSelectedItems(items);
    return this.lastSelectedOptionRecords;
  }
  async getUpdateComplete() {
    var _a2;
    await ((_a2 = this.menu) == null ? void 0 : _a2.updateComplete);
    return super.getUpdateComplete();
  }
  /**
   * Gets the selected options from the DOM, and updates the value and display
   * text to the first selected option's value and headline respectively.
   *
   * @return Whether or not the selected option has changed since last update.
   */
  updateValueAndDisplayText() {
    const selectedOptions = this.getSelectedOptions() ?? [];
    let hasSelectedOptionChanged = false;
    if (selectedOptions.length) {
      const [firstSelectedOption] = selectedOptions[0];
      hasSelectedOptionChanged = this.lastSelectedOption !== firstSelectedOption;
      this.lastSelectedOption = firstSelectedOption;
      this[VALUE] = firstSelectedOption.value;
      this.displayText = firstSelectedOption.headline;
    } else {
      hasSelectedOptionChanged = this.lastSelectedOption !== null;
      this.lastSelectedOption = null;
      this[VALUE] = "";
      this.displayText = "";
    }
    return hasSelectedOptionChanged;
  }
  update(changed) {
    if (!this.hasUpdated) {
      this.initUserSelection();
    }
    super.update(changed);
  }
  async firstUpdated(changed) {
    var _a2;
    await ((_a2 = this.menu) == null ? void 0 : _a2.updateComplete);
    if (!this.lastSelectedOptionRecords.length) {
      this.initUserSelection();
    }
    super.firstUpdated(changed);
  }
  /**
   * Focuses and activates the last selected item upon opening, and resets other
   * active items.
   */
  async handleOpening() {
    var _a2;
    const items = this.menu.items;
    const activeItem = (_a2 = List.getActiveItem(items)) == null ? void 0 : _a2.item;
    const [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];
    if (activeItem && activeItem !== selectedItem) {
      activeItem.active = false;
    }
    if (selectedItem) {
      selectedItem.active = true;
      selectedItem.focus();
    }
  }
  handleClosing() {
    this.open = false;
  }
  /**
   * Determines the reason for closing, and updates the UI accordingly.
   */
  handleCloseMenu(event) {
    const reason = event.reason;
    const item = event.itemPath[0];
    this.open = false;
    let hasChanged = false;
    if (reason.kind === "CLICK_SELECTION") {
      hasChanged = this.selectItem(item);
    } else if (reason.kind === "KEYDOWN" && isSelectableKey(reason.key)) {
      hasChanged = this.selectItem(item);
    } else {
      item.active = false;
      item.blur();
    }
    if (hasChanged) {
      this.dispatchInteractionEvents();
    }
  }
  /**
   * Selects a given option, deselects other options, and updates the UI.
   *
   * @return Whether the last selected option has changed.
   */
  selectItem(item) {
    this.lastSelectedOptionRecords.forEach(([option]) => {
      if (item !== option) {
        option.selected = false;
      }
    });
    item.selected = true;
    return this.updateValueAndDisplayText();
  }
  /**
   * Handles updating selection when an option element requests selection via
   * property / attribute change.
   */
  handleRequestSelection(event) {
    const requestingOptionEl = event.target;
    if (this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.selectItem(requestingOptionEl);
  }
  /**
   * Handles updating selection when an option element requests deselection via
   * property / attribute change.
   */
  handleRequestDeselection(event) {
    const requestingOptionEl = event.target;
    if (!this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.updateValueAndDisplayText();
  }
  /**
   * Selects an option given the value of the option, and updates MdSelect's
   * value.
   */
  select(value) {
    const optionToSelect = this.options.find((option) => option.value === value);
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Selects an option given the index of the option, and updates MdSelect's
   * value.
   */
  selectIndex(index) {
    const optionToSelect = this.options[index];
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Attempts to initialize the selected option from user-settable values like
   * SSR, setting `value`, or `selectedIndex` at startup.
   */
  initUserSelection() {
    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {
      this.select(this.lastUserSetValue);
    } else if (this.lastUserSetSelectedIndex !== null && !this.lastSelectedOptionRecords.length) {
      this.selectIndex(this.lastUserSetSelectedIndex);
    } else {
      this.updateValueAndDisplayText();
    }
  }
  handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
    this.hasTrailingIcon = this.trailingIcons.length > 0;
  }
  /**
   * Dispatches the `input` and `change` events.
   */
  dispatchInteractionEvents() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
_a = VALUE;
__decorate([
  property({ type: Boolean })
], Select.prototype, "quick", void 0);
__decorate([
  property({ type: Boolean })
], Select.prototype, "required", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], Select.prototype, "disabled", void 0);
__decorate([
  property({ type: String, attribute: "error-text" })
], Select.prototype, "errorText", void 0);
__decorate([
  property()
], Select.prototype, "label", void 0);
__decorate([
  property({ type: String, attribute: "supporting-text" })
], Select.prototype, "supportingText", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], Select.prototype, "error", void 0);
__decorate([
  property({ type: Boolean, attribute: "menu-fixed" })
], Select.prototype, "menuFixed", void 0);
__decorate([
  property({ type: Number, attribute: "typeahead-delay" })
], Select.prototype, "typeaheadDelay", void 0);
__decorate([
  property({ type: Boolean, attribute: "has-leading-icon" })
], Select.prototype, "hasLeadingIcon", void 0);
__decorate([
  property({ type: Boolean, attribute: "has-trailing-icon" })
], Select.prototype, "hasTrailingIcon", void 0);
__decorate([
  property({ attribute: "display-text" })
], Select.prototype, "displayText", void 0);
__decorate([
  state()
], Select.prototype, "focused", void 0);
__decorate([
  state()
], Select.prototype, "open", void 0);
__decorate([
  query(".field")
], Select.prototype, "field", void 0);
__decorate([
  query("md-menu")
], Select.prototype, "menu", void 0);
__decorate([
  queryAssignedElements({ slot: "leadingicon", flatten: true })
], Select.prototype, "leadingIcons", void 0);
__decorate([
  queryAssignedElements({ slot: "trailingicon", flatten: true })
], Select.prototype, "trailingIcons", void 0);
__decorate([
  property()
], Select.prototype, "value", null);
__decorate([
  property({ type: Number, attribute: "selected-index" })
], Select.prototype, "selectedIndex", null);

export {
  Select,
  styles
};
/*! Bundled license information:

@material/web/select/internal/shared-styles.css.js:
  (**
    * @license
    * Copyright 2022 Google LLC
    * SPDX-License-Identifier: Apache-2.0
    *)

@material/web/select/internal/select.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=chunk-5DGS5GQK.js.map
