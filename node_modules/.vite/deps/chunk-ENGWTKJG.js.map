{
  "version": 3,
  "sources": ["../../@material/web/menu/internal/forced-colors-styles.css.ts", "../../@material/web/menu/internal/surfacePositionController.ts", "../../@material/web/menu/internal/typeaheadController.ts", "../../@material/web/menu/internal/menu.ts", "../../@material/web/menu/internal/menu-styles.css.ts", "../../@material/web/menu/menu.ts"],
  "sourcesContent": ["/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}/*# sourceMappingURL=forced-colors-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveController, ReactiveControllerHost} from 'lit';\nimport {StyleInfo} from 'lit/directives/style-map.js';\n\n/**\n * A corner of a box in the standard logical property style of <block>_<inline>\n */\nexport type Corner = 'END_START'|'END_END'|'START_START'|'START_END';\n\n/**\n * An interface that provides a method to customize the rect from which to\n * calculate the anchor positioning. Useful for when you want a surface to\n * anchor to an element in your shadow DOM rather than the host element.\n */\nexport interface SurfacePositionTarget extends HTMLElement {\n  getSurfacePositionClientRect?: () => DOMRect;\n}\n\n/**\n * The configurable options for the surface position controller.\n */\nexport interface SurfacePositionControllerProperties {\n  /**\n   * The corner of the anchor to align the surface's position.\n   */\n  anchorCorner: Corner;\n  /**\n   * The corner of the surface to align to the given anchor corner.\n   */\n  surfaceCorner: Corner;\n  /**\n   * The HTMLElement reference of the surface to be positioned.\n   */\n  surfaceEl: SurfacePositionTarget|null;\n  /**\n   * The HTMLElement reference of the anchor to align to.\n   */\n  anchorEl: SurfacePositionTarget|null;\n  /**\n   * Whether or not the calculation should be relative to the top layer rather\n   * than relative to the parent of the anchor.\n   *\n   * Examples for `isTopLayer:true`:\n   *\n   * - If there is no `position:relative` in the given parent tree and the\n   *   surface is `position:absolute`\n   * - If the surface is `position:fixed`\n   * - If the surface is in the \"top layer\"\n   * - The anchor and the surface do not share a common `position:relative`\n   *   ancestor\n   */\n  isTopLayer: boolean;\n  /**\n   * Whether or not the surface should be \"open\" and visible\n   */\n  isOpen: boolean;\n  /**\n   * The number of pixels in which to offset from the inline axis relative to\n   * logical property.\n   *\n   * Positive is right in LTR and left in RTL.\n   */\n  xOffset: number;\n  /**\n   * The number of pixes in which to offset the block axis.\n   *\n   * Positive is down and negative is up.\n   */\n  yOffset: number;\n  /**\n   * A function to call after the surface has been positioned.\n   */\n  onOpen: () => void;\n  /**\n   * A function to call before the surface should be closed. (A good time to\n   * perform animations while the surface is still visible)\n   */\n  beforeClose: () => Promise<void>;\n  /**\n   * A function to call after the surface has been closed.\n   */\n  onClose: () => void;\n}\n\n/**\n * Given a surface, an anchor, corners, and some options, this surface will\n * calculate the position of a surface to align the two given corners and keep\n * the surface inside the window viewport. It also provides a StyleInfo map that\n * can be applied to the surface to handle visiblility and position.\n */\nexport class SurfacePositionController implements ReactiveController {\n  // The current styles to apply to the surface.\n  private surfaceStylesInternal: StyleInfo = {\n    'display': 'none',\n  };\n  // Previous values stored for change detection. Open change detection is\n  // calculated separately so initialize it here.\n  private lastValues: SurfacePositionControllerProperties = {isOpen: false} as\n      SurfacePositionControllerProperties;\n\n  /**\n   * @param host The host to connect the controller to.\n   * @param getProperties A function that returns the properties for the\n   * controller.\n   */\n  constructor(\n      private readonly host: ReactiveControllerHost,\n      private readonly getProperties: () => SurfacePositionControllerProperties,\n  ) {\n    this.host.addController(this);\n  }\n\n  /**\n   * The StyleInfo map to apply to the surface via Lit's stylemap\n   */\n  get surfaceStyles() {\n    return this.surfaceStylesInternal;\n  }\n\n  /**\n   * Calculates the surface's new position required so that the surface's\n   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the\n   * surface inside the window viewport. This positioning also respects RTL by\n   * checking `getComputedStyle()` on the surface element.\n   */\n  async position() {\n    const {\n      surfaceEl,\n      anchorEl,\n      anchorCorner: anchorCornerRaw,\n      surfaceCorner: surfaceCornerRaw,\n      isTopLayer: topLayerRaw,\n      xOffset,\n      yOffset,\n    } = this.getProperties();\n    const anchorCorner = anchorCornerRaw.toUpperCase().trim();\n    const surfaceCorner = surfaceCornerRaw.toUpperCase().trim();\n\n    if (!surfaceEl || !anchorEl) {\n      return;\n    }\n\n    // Paint the surface transparently so that we can get the position and the\n    // rect info of the surface.\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '0',\n    };\n\n    // Wait for it to be visible.\n    this.host.requestUpdate();\n    await this.host.updateComplete;\n\n    const surfaceRect = surfaceEl.getSurfacePositionClientRect ?\n        surfaceEl.getSurfacePositionClientRect() :\n        surfaceEl.getBoundingClientRect();\n    const anchorRect = anchorEl.getSurfacePositionClientRect ?\n        anchorEl.getSurfacePositionClientRect() :\n        anchorEl.getBoundingClientRect();\n    const [surfaceBlock, surfaceInline] =\n        surfaceCorner.split('_') as Array<'START'|'END'>;\n    const [anchorBlock, anchorInline] =\n        anchorCorner.split('_') as Array<'START'|'END'>;\n\n\n    // We use number booleans to multiply values rather than `if` / ternary\n    // statements because it _heavily_ cuts down on nesting and readability\n    const isTopLayer = topLayerRaw ? 1 : 0;\n    // LTR depends on the direction of the SURFACE not the anchor.\n    const isLTR =\n        getComputedStyle(surfaceEl as HTMLElement).direction === 'ltr' ? 1 : 0;\n    const isRTL = isLTR ? 0 : 1;\n    const isSurfaceInlineStart = surfaceInline === 'START' ? 1 : 0;\n    const isSurfaceInlineEnd = surfaceInline === 'END' ? 1 : 0;\n    const isSurfaceBlockStart = surfaceBlock === 'START' ? 1 : 0;\n    const isSurfaceBlockEnd = surfaceBlock === 'END' ? 1 : 0;\n    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;\n    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;\n\n    /*\n     * A diagram that helps describe some of the variables used in the following\n     * calculations.\n     *\n     * ┌───── inline/blockTopLayerOffset\n     * │       │\n     * │     ┌─▼───┐                  Window\n     * │    ┌┼─────┴────────────────────────┐\n     * │    ││                              │\n     * └──► ││  ┌──inline/blockAnchorOffset │\n     *      ││  │     │                     │\n     *      └┤  │  ┌──▼───┐                 │\n     *       │  │ ┌┼──────┤                 │\n     *       │  └─►│Anchor│                 │\n     *       │    └┴──────┘                 │\n     *       │                              │\n     *       │     ┌────────────────────────┼────┐\n     *       │     │ Surface                │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       └─────┼────────────────────────┘    ├┐\n     *             │ inline/blockOOBCorrection   ││\n     *             │                         │   ││\n     *             │                         ├──►││\n     *             │                         │   ││\n     *             └────────────────────────┐▼───┼┘\n     *                                      └────┘\n     */\n\n    // Whether or not to apply the width of the anchor\n    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;\n    // The inline position of the anchor relative to window in LTR\n    const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left +\n        isSurfaceInlineEnd * (window.innerWidth - anchorRect.right);\n    // The inline position of the anchor relative to window in RTL\n    const inlineTopLayerOffsetRTL =\n        isSurfaceInlineStart * (window.innerWidth - anchorRect.right) +\n        isSurfaceInlineEnd * anchorRect.left;\n    // The inline position of the anchor relative to window\n    const inlineTopLayerOffset =\n        isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;\n    // If the surface's inline would be out of bounds of the window, move it\n    // back in\n    const inlineOutOfBoundsCorrection = Math.min(\n        0,\n        window.innerWidth - inlineTopLayerOffset - inlineAnchorOffset -\n            surfaceRect.width);\n\n    // The inline logical value of the surface\n    const inline = isTopLayer * inlineTopLayerOffset + inlineAnchorOffset +\n        inlineOutOfBoundsCorrection;\n\n    // Whether or not to apply the height of the anchor\n    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;\n    // The absolute block position of the anchor relative to window\n    const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top +\n        isSurfaceBlockEnd * (window.innerHeight - anchorRect.bottom);\n    // If the surface's block would be out of bounds of the window, move it back\n    // in\n    const blockOutOfBoundsCorrection = Math.min(\n        0,\n        window.innerHeight - blockTopLayerOffset - blockAnchorOffset -\n            surfaceRect.height);\n\n    // The block logical value of the surface\n    const block = isTopLayer * blockTopLayerOffset + blockAnchorOffset +\n        blockOutOfBoundsCorrection;\n\n    const surfaceBlockProperty =\n        surfaceBlock === 'START' ? 'inset-block-start' : 'inset-block-end';\n    const surfaceInlineProperty =\n        surfaceInline === 'START' ? 'inset-inline-start' : 'inset-inline-end';\n\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '1',\n      [surfaceBlockProperty]: `${block}px`,\n      [surfaceInlineProperty]: `${inline}px`,\n    };\n\n    this.host.requestUpdate();\n  }\n\n  hostUpdate() {\n    this.onUpdate();\n  }\n\n  hostUpdated() {\n    this.onUpdate();\n  }\n\n  /**\n   * Checks whether the properties passed into the controller have changed since\n   * the last positioning. If so, it will reposition if the surface is open or\n   * close it if the surface should close.\n   */\n  private async onUpdate() {\n    const props = this.getProperties();\n    let hasChanged = false;\n    for (const [key, value] of Object.entries(props)) {\n      // tslint:disable-next-line\n      hasChanged = hasChanged || (value !== (this.lastValues as any)[key]);\n      if (hasChanged) break;\n    }\n\n    const openChanged = this.lastValues.isOpen !== props.isOpen;\n    const hasAnchor = !!props.anchorEl;\n    const hasSurface = !!props.surfaceEl;\n\n    if (hasChanged && hasAnchor && hasSurface) {\n      // Only update isOpen, because if it's closed, we do not want to waste\n      // time on a useless reposition calculation. So save the other \"dirty\"\n      // values until next time it opens.\n      this.lastValues.isOpen = props.isOpen;\n\n      if (props.isOpen) {\n        // We are going to do a reposition, so save the prop values for future\n        // dirty checking.\n        this.lastValues = props;\n\n        await this.position();\n        props.onOpen();\n      } else if (openChanged) {\n        await props.beforeClose();\n        this.close();\n        props.onClose();\n      }\n    }\n  }\n\n  /**\n   * Hides the surface.\n   */\n  private close() {\n    this.surfaceStylesInternal = {\n      'display': 'none',\n    };\n    this.host.requestUpdate();\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {MenuItem} from './shared.js';\n\n/**\n * The options that are passed to the typeahead controller.\n */\nexport interface TypeaheadControllerProperties {\n  /**\n   * A function that returns an array of menu items to be searched.\n   * @return An array of menu items to be searched by typing.\n   */\n  getItems: () => MenuItem[];\n  /**\n   * The maximum time between each keystroke to keep the current type buffer\n   * alive.\n   */\n  typeaheadBufferTime: number;\n  /**\n   * Whether or not the typeahead should listen for keystrokes or not.\n   */\n  active: boolean;\n}\n\n/**\n * Data structure tuple that helps with indexing.\n *\n * [index, item, normalized header text]\n */\ntype TypeaheadRecord = [number, MenuItem, string];\n/**\n * Indicies to access the TypeaheadRecord tuple type.\n */\nexport const TYPEAHEAD_RECORD = {\n  INDEX: 0,\n  ITEM: 1,\n  TEXT: 2,\n} as const;\n\n/**\n * This controller listens to `keydown` events and searches the header text of\n * an array of `MenuItem`s with the corresponding entered keys within the buffer\n * time and activates the item.\n *\n * @example\n * ```ts\n * const typeaheadController = new TypeaheadController(() => ({\n *   typeaheadBufferTime: 50,\n *   getItems: () => Array.from(document.querySelectorAll('md-menu-item'))\n * }));\n * html`\n *   <div\n *       @keydown=${typeaheadController.onKeydown}\n *       tabindex=\"0\"\n *       class=\"activeItemText\">\n *     <!-- focusable element that will receive keydown events -->\n *     Apple\n *   </div>\n *   <div>\n *     <md-menu-item active header=\"Apple\"></md-menu-item>\n *     <md-menu-item header=\"Apricot\"></md-menu-item>\n *     <md-menu-item header=\"Banana\"></md-menu-item>\n *     <md-menu-item header=\"Olive\"></md-menu-item>\n *     <md-menu-item header=\"Orange\"></md-menu-item>\n *   </div>\n * `;\n * ```\n */\nexport class TypeaheadController {\n  /**\n   * Array of tuples that helps with indexing.\n   */\n  private typeaheadRecords: TypeaheadRecord[] = [];\n  /**\n   * Currently-typed text since last buffer timeout\n   */\n  private typaheadBuffer = '';\n  /**\n   * The timeout id from the current buffer's setTimeout\n   */\n  private cancelTypeaheadTimeout = 0;\n  /**\n   * If we are currently \"typing\"\n   */\n  isTypingAhead = false;\n  /**\n   * The record of the last active item.\n   */\n  lastActiveRecord: TypeaheadRecord|null = null;\n\n  /**\n   * @param getProperties A function that returns the options of the typeahead\n   * controller:\n   *\n   * {\n   *   getItems: A function that returns an array of menu items to be searched.\n   *   typeaheadBufferTime: The maximum time between each keystroke to keep the\n   *       current type buffer alive.\n   * }\n   */\n  constructor(\n      private readonly getProperties: () => TypeaheadControllerProperties,\n  ) {}\n\n  private get items() {\n    return this.getProperties().getItems();\n  }\n\n  private get active() {\n    return this.getProperties().active;\n  }\n\n  /**\n   * Apply this listener to the element that will receive `keydown` events that\n   * should trigger this controller.\n   *\n   * @param event The native browser `KeyboardEvent` from the `keydown` event.\n   */\n  readonly onKeydown = (event: KeyboardEvent) => {\n    if (this.isTypingAhead) {\n      this.typeahead(event);\n    } else {\n      this.beginTypeahead(event);\n    }\n  };\n\n  /**\n   * Sets up typingahead\n   */\n  private beginTypeahead(event: KeyboardEvent) {\n    if (!this.active) {\n      return;\n    }\n\n    // We don't want to typeahead if the _beginning_ of the typeahead is a menu\n    // navigation, or a selection. We will handle \"Space\" only if it's in the\n    // middle of a typeahead\n    if (event.code === 'Space' || event.code === 'Enter' ||\n        event.code.startsWith('Arrow') || event.code === 'Escape') {\n      return;\n    }\n\n    this.isTypingAhead = true;\n    // Generates the record array data structure which is the index, the element\n    // and a normalized header.\n    this.typeaheadRecords = this.items.map(\n        (el, index) => [index, el, el.headline.trim().toLowerCase()]);\n    this.lastActiveRecord =\n        this.typeaheadRecords.find(\n            record => record[TYPEAHEAD_RECORD.ITEM].active) ??\n        null;\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n    }\n    this.typeahead(event);\n  }\n\n  /**\n   * Performs the typeahead. Based on the normalized items and the current text\n   * buffer, finds the _next_ item with matching text and activates it.\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: 'o'\n   * user types: l\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Orange\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange (active), Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   */\n  private typeahead(event: KeyboardEvent) {\n    clearTimeout(this.cancelTypeaheadTimeout);\n    // Stop typingahead if one of the navigation or selection keys (except for\n    // Space) are pressed\n    if (event.code === 'Enter' || event.code.startsWith('Arrow') ||\n        event.code === 'Escape') {\n      this.endTypeahead();\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n      }\n      return;\n    }\n\n    // If Space is pressed, prevent it from selecting and closing the menu\n    if (event.code === 'Space') {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n\n    // Start up a new keystroke buffer timeout\n    this.cancelTypeaheadTimeout =\n        setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);\n\n    this.typaheadBuffer += event.key.toLowerCase();\n\n    const lastActiveIndex = this.lastActiveRecord ?\n        this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] :\n        -1;\n    const numRecords = this.typeaheadRecords.length;\n\n    /**\n     * Sorting function that will resort the items starting with the given index\n     *\n     * @example\n     *\n     * this.typeaheadRecords =\n     * 0: [0, <reference>, 'apple']\n     * 1: [1, <reference>, 'apricot']\n     * 2: [2, <reference>, 'banana']\n     * 3: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 4: [4, <reference>, 'orange']\n     * 5: [5, <reference>, 'strawberry']\n     *\n     * this.typeaheadRecords.sort((a,b) => rebaseIndexOnActive(a)\n     *                                       - rebaseIndexOnActive(b)) ===\n     * 0: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 1: [4, <reference>, 'orange']\n     * 2: [5, <reference>, 'strawberry']\n     * 3: [0, <reference>, 'apple']\n     * 4: [1, <reference>, 'apricot']\n     * 5: [2, <reference>, 'banana']\n     */\n    const rebaseIndexOnActive = (record: TypeaheadRecord) => {\n      return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) %\n          numRecords;\n    };\n\n    // records filtered and sorted / rebased around the last active index\n    const matchingRecords =\n        this.typeaheadRecords\n            .filter(\n                record => !record[TYPEAHEAD_RECORD.ITEM].disabled &&\n                    record[TYPEAHEAD_RECORD.TEXT].startsWith(\n                        this.typaheadBuffer))\n            .sort((a, b) => rebaseIndexOnActive(a) - rebaseIndexOnActive(b));\n\n    // Just leave if there's nothing that matches. Native select will just\n    // choose the first thing that starts with the next letter in the alphabet\n    // but that's out of scope and hard to localize\n    if (matchingRecords.length === 0) {\n      clearTimeout(this.cancelTypeaheadTimeout);\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n      }\n      this.endTypeahead();\n      return;\n    }\n\n    const isNewQuery = this.typaheadBuffer.length === 1;\n    let nextRecord: TypeaheadRecord;\n\n    // This is likely the case that someone is trying to \"tab\" through different\n    // entries that start with the same letter\n    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {\n      nextRecord = matchingRecords[1] ?? matchingRecords[0];\n    } else {\n      nextRecord = matchingRecords[0];\n    }\n\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n    }\n\n    this.lastActiveRecord = nextRecord;\n    nextRecord[TYPEAHEAD_RECORD.ITEM].active = true;\n    return;\n  }\n\n  /**\n   * Ends the current typeahead and clears the buffer.\n   */\n  private readonly endTypeahead = () => {\n    this.isTypingAhead = false;\n    this.typaheadBuffer = '';\n    this.typeaheadRecords = [];\n  };\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../list/list.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../elevation/elevation.js';\n\nimport {html, isServer, LitElement, nothing} from 'lit';\nimport {eventOptions, property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {ARIAMixinStrict, ARIARole} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {createAnimationSignal, EASING} from '../../internal/motion/animation.js';\nimport {List} from '../../list/internal/list.js';\n\nimport {ActivateTypeaheadEvent, DeactivateTypeaheadEvent, isClosableKey, isElementInSubtree, MenuItem} from './shared.js';\nimport {Corner, SurfacePositionController, SurfacePositionTarget} from './surfacePositionController.js';\nimport {TypeaheadController} from './typeaheadController.js';\n\nexport {Corner} from './surfacePositionController.js';\n\n/**\n * The default value for the typeahead buffer time in Milliseconds.\n */\nexport const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;\n\n/**\n * Element to focus on when menu is first opened.\n */\nexport type DefaultFocusState = 'NONE'|'LIST_ROOT'|'FIRST_ITEM'|'LAST_ITEM';\n\n/**\n * Gets the currently focused element on the page.\n *\n * @param activeDoc The document or shadowroot from which to start the search.\n *    Defaults to `window.document`\n * @return Returns the currently deeply focused element or `null` if none.\n */\nfunction getFocusedElement(activeDoc: Document|ShadowRoot = document):\n    HTMLElement|null {\n  const activeEl = activeDoc.activeElement as HTMLElement | null;\n\n  if (!activeEl) {\n    return null;\n  }\n\n  if (activeEl.shadowRoot) {\n    return getFocusedElement(activeEl.shadowRoot) ?? activeEl;\n  }\n\n  return activeEl;\n}\n\n/**\n * @fires opening Fired before the opening animation begins\n * @fires opened Fired once the menu is open, after any animations\n * @fires closing Fired before the closing animation begins\n * @fires closed Fired once the menu is closed, after any animations\n */\nexport abstract class Menu extends LitElement {\n  static {\n    requestUpdateOnAriaChange(Menu);\n  }\n\n  @query('md-list') private readonly listElement!: List|null;\n  @query('.menu') private readonly surfaceEl!: HTMLElement|null;\n  @query('slot') private readonly slotEl!: HTMLSlotElement|null;\n\n  /**\n   * The element in which the menu should align to.\n   */\n  @property({attribute: false})\n  anchor: HTMLElement&Partial<SurfacePositionTarget>|null = null;\n  /**\n   * Makes the element use `position:fixed` instead of `position:absolute`. In\n   * most cases, the menu should position itself above most other\n   * `position:absolute` or `position:fixed` elements when placed inside of\n   * them. e.g. using a menu inside of an `md-dialog`.\n   *\n   * __NOTE__: Fixed menus will not scroll with the page and will be fixed to\n   * the window instead.\n   */\n  @property({type: Boolean}) fixed = false;\n  /**\n   * Skips the opening and closing animations.\n   */\n  @property({type: Boolean}) quick = false;\n  /**\n   * Displays overflow content like a submenu.\n   *\n   * __NOTE__: This may cause adverse effects if you set\n   * `md-menu {max-height:...}`\n   * and have items overflowing items in the \"y\" direction.\n   */\n  @property({type: Boolean, attribute: 'has-overflow'}) hasOverflow = false;\n  /**\n   * Opens the menu and makes it visible. Alternative to the `.show()` and\n   * `.close()` methods\n   */\n  @property({type: Boolean, reflect: true}) open = false;\n  /**\n   * Offsets the menu's inline alignment from the anchor by the given number in\n   * pixels. This value is direction aware and will follow the LTR / RTL\n   * direction.\n   *\n   * e.g. LTR: positive -> right, negative -> left\n   *      RTL: positive -> left, negative -> right\n   */\n  @property({type: Number, attribute: 'x-offset'}) xOffset = 0;\n  /**\n   * Offsets the menu's block alignment from the anchor by the given number in\n   * pixels.\n   *\n   * e.g. positive -> down, negative -> up\n   */\n  @property({type: Number, attribute: 'y-offset'}) yOffset = 0;\n  /**\n   * The tabindex of the underlying list element.\n   */\n  @property({type: Number, attribute: 'list-tabindex'}) listTabIndex = 0;\n  /**\n   * The role of the underlying list element.\n   */\n  @property() type: ARIARole = 'menu';\n  /**\n   * The max time between the keystrokes of the typeahead menu behavior before\n   * it clears the typeahead buffer.\n   */\n  @property({type: Number, attribute: 'typeahead-delay'})\n  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n  /**\n   * The corner of the anchor which to align the menu in the standard logical\n   * property style of <block>_<inline>.\n   */\n  @property({attribute: 'anchor-corner'}) anchorCorner: Corner = 'END_START';\n  /**\n   * The corner of the menu which to align the anchor in the standard logical\n   * property style of <block>_<inline>.\n   */\n  @property({attribute: 'menu-corner'}) menuCorner: Corner = 'START_START';\n  /**\n   * Keeps the user clicks outside the menu.\n   *\n   * NOTE: clicking outside may still cause focusout to close the menu so see\n   * `stayOpenOnFocusout`.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-outside-click'})\n  stayOpenOnOutsideClick = false;\n  /**\n   * Keeps the menu open when focus leaves the menu's composed subtree.\n   *\n   * NOTE: Focusout behavior will stop propagation of the focusout event. Set\n   * this property to true to opt-out of menu's focuout handling altogether.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-focusout'})\n  stayOpenOnFocusout = false;\n  /**\n   * After closing, does not restore focus to the last focused element before\n   * the menu was opened.\n   */\n  @property({type: Boolean, attribute: 'skip-restore-focus'})\n  skipRestoreFocus = false;\n  /**\n   * The element that should be focused by default once opened.\n   */\n  @property({attribute: 'default-focus'})\n  defaultFocus: DefaultFocusState = 'LIST_ROOT';\n\n  @state() private typeaheadActive = true;\n\n  private readonly openCloseAnimationSignal = createAnimationSignal();\n\n  /**\n   * Whether the menu is animating upwards or downwards when opening. This is\n   * helpful for calculating some animation calculations.\n   */\n  private get openDirection(): 'UP'|'DOWN' {\n    const menuCornerBlock = this.menuCorner.split('_')[0];\n    return menuCornerBlock === 'START' ? 'DOWN' : 'UP';\n  }\n\n  /**\n   * The element that was focused before the menu opened.\n   */\n  private lastFocusedElement: HTMLElement|null = null;\n\n  /**\n   * Handles typeahead navigation through the menu.\n   */\n  typeaheadController = new TypeaheadController(() => {\n    return {\n      getItems: () => this.items,\n      typeaheadBufferTime: this.typeaheadDelay,\n      active: this.typeaheadActive\n    };\n  });\n\n  /**\n   * Handles positioning the surface and aligning it to the anchor.\n   */\n  private readonly menuPositionController =\n      new SurfacePositionController(this, () => {\n        return {\n          anchorCorner: this.anchorCorner,\n          surfaceCorner: this.menuCorner,\n          surfaceEl: this.surfaceEl,\n          anchorEl: this.anchor,\n          isTopLayer: this.fixed,\n          isOpen: this.open,\n          xOffset: this.xOffset,\n          yOffset: this.yOffset,\n          onOpen: this.onOpened,\n          beforeClose: this.beforeClose,\n          onClose: this.onClosed,\n        };\n      });\n\n  /**\n   * The menu items associated with this menu. The items must be `MenuItem`s and\n   * have both the `md-menu-item` and `md-list-item` attributes.\n   */\n  get items(): MenuItem[] {\n    const listElement = this.listElement;\n\n    if (listElement) {\n      return listElement.items.filter(el => el.hasAttribute('md-menu-item')) as\n          MenuItem[];\n    }\n\n    return [];\n  }\n\n  protected override render() {\n    return this.renderSurface();\n  }\n\n  /**\n   * Renders the positionable surface element and its contents.\n   */\n  private renderSurface() {\n    // TODO(b/274140618): elevation should be an underlay, not an overlay that\n    // tints content\n    return html`\n       <div\n          class=\"menu ${classMap(this.getSurfaceClasses())}\"\n          style=${styleMap(this.menuPositionController.surfaceStyles)}\n          @focusout=${this.handleFocusout}>\n        ${this.renderElevation()}\n        ${this.renderList()}\n        ${this.renderFocusRing()}\n       </div>\n     `;\n  }\n\n  /**\n   * Renders the List element and its items\n   */\n  private renderList() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return html`\n      <md-list\n          part=\"list\"\n          id=\"list\"\n          aria-label=${ariaLabel || nothing}\n          type=${this.type}\n          listTabIndex=${this.listTabIndex}\n          @keydown=${this.handleListKeydown}>\n        ${this.renderMenuItems()}\n      </md-list>`;\n  }\n\n  /**\n   * Renders the menu items' slot\n   */\n  private renderMenuItems() {\n    return html`<slot\n        @close-menu=${this.onCloseMenu}\n        @deactivate-items=${this.onDeactivateItems}\n        @deactivate-typeahead=${this.handleDeactivateTypeahead}\n        @activate-typeahead=${this.handleActivateTypeahead}\n        @stay-open-on-focusout=${this.handleStayOpenOnFocusout}\n        @close-on-focusout=${this.handleCloseOnFocusout}></slot>`;\n  }\n\n  /**\n   * Renders the elevation component.\n   */\n  private renderElevation() {\n    return html`<md-elevation part=\"elevation\"></md-elevation>`;\n  }\n\n  /**\n   * Renders the focus ring component.\n   */\n  private renderFocusRing() {\n    return html`<md-focus-ring part=\"focus-ring\" for=\"list\"></md-focus-ring>`;\n  }\n\n  private getSurfaceClasses() {\n    return {\n      open: this.open,\n      fixed: this.fixed,\n      'has-overflow': this.hasOverflow,\n    };\n  }\n\n  private async handleFocusout(event: FocusEvent) {\n    if (this.stayOpenOnFocusout) {\n      return;\n    }\n\n    // Stop propagation to prevent nested menus from interfering with each other\n    event.stopPropagation();\n\n    if (event.relatedTarget) {\n      // Don't close the menu if we are switching focus between menu,\n      // md-menu-item, and md-list\n      if (isElementInSubtree(event.relatedTarget, this)) {\n        return;\n      }\n    }\n\n    const oldRestoreFocus = this.skipRestoreFocus;\n    // allow focus to continue to the next focused object rather than returning\n    this.skipRestoreFocus = true;\n    this.close();\n    // await for close\n    await this.updateComplete;\n    // return to previous behavior\n    this.skipRestoreFocus = oldRestoreFocus;\n  }\n\n  // Capture so that we can grab the event before it reaches the list item\n  // istelf. Specifically useful for the case where typeahead encounters a space\n  // and we don't want the menu item to close the menu.\n  @eventOptions({capture: true})\n  private handleListKeydown(event: KeyboardEvent) {\n    if (event.target === this.listElement && !event.defaultPrevented &&\n        isClosableKey(event.code)) {\n      event.preventDefault();\n      this.close();\n    }\n\n    this.typeaheadController.onKeydown(event);\n  }\n\n  /**\n   * Saves the last focused element focuses the new element based on\n   * `defaultFocus`, and animates open.\n   */\n  private readonly onOpened = () => {\n    this.lastFocusedElement = getFocusedElement();\n\n    if (!this.listElement) return;\n\n    const items = this.listElement.items;\n    const activeItemRecord = List.getActiveItem(items);\n\n    if (activeItemRecord && this.defaultFocus !== 'NONE') {\n      activeItemRecord.item.active = false;\n    }\n\n    switch (this.defaultFocus) {\n      case 'FIRST_ITEM':\n        const first = List.getFirstActivatableItem(items);\n        if (first) {\n          first.active = true;\n        }\n        break;\n      case 'LAST_ITEM':\n        const last = List.getLastActivatableItem(items);\n        if (last) {\n          last.active = true;\n        }\n        break;\n      case 'LIST_ROOT':\n        this.listElement?.focus();\n        break;\n      default:\n      case 'NONE':\n        // Do nothing.\n        break;\n    }\n\n    if (this.quick) {\n      this.dispatchEvent(new Event('opening'));\n      this.dispatchEvent(new Event('opened'));\n    } else {\n      this.animateOpen();\n    }\n  };\n\n  /**\n   * Animates closed.\n   */\n  private readonly beforeClose = async () => {\n    this.open = false;\n\n    if (!this.skipRestoreFocus) {\n      this.lastFocusedElement?.focus?.();\n    }\n\n    if (!this.quick) {\n      await this.animateClose();\n    }\n  };\n\n  /**\n   * Focuses the last focused element.\n   */\n  private readonly onClosed = () => {\n    if (this.quick) {\n      this.dispatchEvent(new Event('closing'));\n      this.dispatchEvent(new Event('closed'));\n    }\n  };\n\n  /**\n   * Performs the opening animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   */\n  private animateOpen() {\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) return;\n\n    const openDirection = this.openDirection;\n    this.dispatchEvent(new Event('opening'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const openingUpwards = openDirection === 'UP';\n    const children = this.items;\n    const FULL_DURATION = 500;\n    const SURFACE_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_DURATION = 250;\n    // We want to fit every child fade-in animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;\n\n    const surfaceHeightAnimation =\n        surfaceEl.animate([{height: '0px'}, {height: `${height}px`}], {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED,\n        });\n    // When we are opening upwards, we want to make sure the last item is always\n    // in view, so we need to translate it upwards the opposite direction of the\n    // height animation\n    const upPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: openingUpwards ? `translateY(-${height}px)` : ''},\n          {transform: ''}\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 0}, {opacity: 1}], SURFACE_OPACITY_DURATION);\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If we are animating upwards, then reverse the children list.\n      const directionalIndex = openingUpwards ? children.length - 1 - i : i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 0}, {opacity: 1}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make them all initially hidden and then clean up at the end of each\n      // animation.\n      child.classList.toggle('hidden', true);\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('hidden', false);\n      });\n\n      childrenAnimations.push([child, animation]);\n    }\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      upPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        child.classList.toggle('hidden', false);\n        animation.cancel();\n      });\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      this.openCloseAnimationSignal.finish();\n      this.dispatchEvent(new Event('opened'));\n    });\n  }\n\n  /**\n   * Performs the closing animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   */\n  private animateClose() {\n    let resolve!: (value: unknown) => void;\n    let reject!: () => void;\n\n    // This promise blocks the surface position controller from setting\n    // display: none on the surface which will interfere with this animation.\n    const animationEnded = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) {\n      reject();\n      return animationEnded;\n    }\n\n    const openDirection = this.openDirection;\n    const closingDownwards = openDirection === 'UP';\n    this.dispatchEvent(new Event('closing'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const children = this.items;\n    const FULL_DURATION = 150;\n    const SURFACE_OPACITY_DURATION = 50;\n    // The surface fades away at the very end\n    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;\n    const ITEM_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_INITIAL_DELAY = 50;\n    const END_HEIGHT_PERCENTAGE = .35;\n\n    // We want to fit every child fade-out animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) /\n        children.length;\n\n    // The mock has the animation shrink to 35%\n    const surfaceHeightAnimation = surfaceEl.animate(\n        [\n          {height: `${height}px`},\n          {height: `${height * END_HEIGHT_PERCENTAGE}px`}\n        ],\n        {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED_ACCELERATE,\n        });\n\n    // When we are closing downwards, we want to make sure the last item is\n    // always in view, so we need to translate it upwards the opposite direction\n    // of the height animation\n    const downPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: ''}, {\n            transform: closingDownwards ?\n                `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` :\n                ''\n          }\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 1}, {opacity: 0}],\n        {duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY});\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If the animation is closing upwards, then reverse the list of\n      // children so that we animate in the opposite direction.\n      const directionalIndex = closingDownwards ? i : children.length - 1 - i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 1}, {opacity: 0}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make sure the items stay hidden at the end of each child animation.\n      // We clean this up at the end of the overall animation.\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('hidden', true);\n      });\n      childrenAnimations.push([child, animation]);\n    }\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      downPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        animation.cancel();\n        child.classList.toggle('hidden', false);\n      });\n      reject();\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      childrenAnimations.forEach(([child]) => {\n        child.classList.toggle('hidden', false);\n      });\n      this.openCloseAnimationSignal.finish();\n      this.dispatchEvent(new Event('closed'));\n      resolve(true);\n    });\n\n    return animationEnded;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    if (!isServer) {\n      window.addEventListener('click', this.onWindowClick, {capture: true});\n    }\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    if (!isServer) {\n      window.removeEventListener('click', this.onWindowClick, {capture: true});\n    }\n  }\n\n  private readonly onWindowClick = (event: MouseEvent) => {\n    if (!this.stayOpenOnOutsideClick && !event.composedPath().includes(this)) {\n      this.open = false;\n    }\n  };\n\n  private onCloseMenu() {\n    this.close();\n  }\n\n  private onDeactivateItems(event: Event) {\n    event.stopPropagation();\n    const items = this.items;\n    for (const item of items) {\n      item.active = false;\n      item.selected = false;\n    }\n  }\n\n  private handleDeactivateTypeahead(event: DeactivateTypeaheadEvent) {\n    // stopPropagation so that this does not deactivate any typeaheads in menus\n    // nested above it e.g. md-sub-menu-item\n    event.stopPropagation();\n    this.typeaheadActive = false;\n  }\n\n  private handleActivateTypeahead(event: ActivateTypeaheadEvent) {\n    // stopPropagation so that this does not activate any typeaheads in menus\n    // nested above it e.g. md-sub-menu-item\n    event.stopPropagation();\n    this.typeaheadActive = true;\n  }\n\n  private handleStayOpenOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = true;\n  }\n\n  private handleCloseOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = false;\n  }\n\n  override focus() {\n    this.listElement?.focus();\n  }\n\n  close() {\n    this.open = false;\n    this.items.forEach(item => {\n      item.close?.();\n    });\n  }\n\n  show() {\n    this.open = true;\n  }\n\n  /**\n   * Activates the next item in the menu. If at the end of the menu, the first\n   * item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activateNextItem() {\n    return this.listElement?.activateNextItem() as MenuItem ?? null;\n  }\n\n  /**\n   * Activates the previous item in the menu. If at the start of the menu, the\n   * last item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activatePreviousItem() {\n    return this.listElement?.activatePreviousItem() as MenuItem ?? null;\n  }\n}\n", "/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{--_container-color: var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));--_container-elevation: var(--md-menu-container-elevation, 2);--_container-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-shape: var(--md-menu-container-shape, 4px);--md-list-container-color: var(--_container-color);--md-elevation-level:var(--_container-elevation);--md-elevation-shadow-color:var(--_container-shadow-color);min-width:300px}md-focus-ring{--md-focus-ring-shape: var(--_container-shape)}.menu{border-radius:var(--_container-shape);display:none;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit}.menu.fixed{position:fixed}.menu md-list{height:inherit;max-height:inherit;display:block;overflow:auto;min-width:inherit;border-radius:inherit}.menu.has-overflow md-list{overflow:visible}.menu.animating md-list{pointer-events:none;overflow:hidden}.menu.animating ::slotted(.hidden){opacity:0}.menu slot{display:block;height:inherit;max-height:inherit}/*# sourceMappingURL=menu-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {customElement} from 'lit/decorators.js';\n\nimport {styles as forcedColors} from './internal/forced-colors-styles.css.js';\nimport {Menu} from './internal/menu.js';\nimport {styles} from './internal/menu-styles.css.js';\n\nexport {ListItem} from '../list/internal/listitem/list-item.js';\nexport {Corner, DefaultFocusState} from './internal/menu.js';\nexport {CloseMenuEvent, MenuItem} from './internal/shared.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'md-menu': MdMenu;\n  }\n}\n\n/**\n * @summary Menus display a list of choices on a temporary surface.\n *\n * @description\n * Menus appear when users interact with a button, action, or other control.\n *\n * They can be opened from a variety of elements, most commonly icon buttons,\n * buttons, and text fields.\n *\n * md-menu listens for the `close-menu` and `deselect-items` events.\n *\n * - `close-menu` closes the menu when dispatched from a child element.\n * - `deselect-items` deselects all of its immediate menu-item children.\n *\n * @example\n * ```html\n * <div style=\"position:relative;\">\n *   <button\n *       class=\"anchor\"\n *       ${ref(anchorRef)}\n *       @click=${() => this.menuRef.value.show()}>\n *     Click to open menu\n *   </button>\n *   <!--\n *     `has-overflow` is required when using a submenu which overflows the\n *     menu's contents\n *   -->\n *   <md-menu has-overflow ${ref(menuRef)} ${(el) => el.anchor =\n * anchorRef.value}> <md-menu-item header=\"This is a header\"></md-menu-item>\n *     <md-sub-menu-item header=\"this is a submenu item\">\n *       <md-menu slot=\"submenu\">\n *         <md-menu-item\n *           header=\"This is an item inside a submenu\"></md-menu-item>\n *       </md-menu>\n *     </md-sub-menu-item>\n *   </md-menu>\n * </div>\n * ```\n *\n * @final\n * @suppress {visibility}\n */\n@customElement('md-menu')\nexport class MdMenu extends Menu {\n  static override styles = [styles, forcedColors];\n}\n"],
  "mappings": "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",
  "names": ["styles", "MdMenu", "styles"]
}
