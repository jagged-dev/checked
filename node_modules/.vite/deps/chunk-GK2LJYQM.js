import {
  requestUpdateOnAriaChange
} from "./chunk-G7CEFHTH.js";
import {
  LitElement,
  __decorate,
  html,
  nothing,
  property,
  query,
  queryAssignedElements
} from "./chunk-CFLWIKS3.js";

// node_modules/@material/web/list/internal/list.js
var NAVIGABLE_KEYS = {
  ArrowDown: "ArrowDown",
  ArrowUp: "ArrowUp",
  Home: "Home",
  End: "End"
};
var navigableKeySet = new Set(Object.values(NAVIGABLE_KEYS));
function isNavigableKey(key) {
  return navigableKeySet.has(key);
}
var List = class _List extends LitElement {
  constructor() {
    super(...arguments);
    this.type = "list";
    this.listTabIndex = 0;
  }
  render() {
    return this.renderList();
  }
  /**
   * Renders the main list element.
   */
  renderList() {
    const { ariaLabel } = this;
    return html`
    <ul class="md3-list"
        aria-label=${ariaLabel || nothing}
        tabindex=${this.listTabIndex}
        role=${this.type || nothing}
        @keydown=${this.handleKeydown}
        >
      ${this.renderContent()}
    </ul>
  `;
  }
  /**
   * The content to be slotted into the list.
   */
  renderContent() {
    return html`<span><slot @click=${(event) => {
      event.stopPropagation();
    }}></slot></span>`;
  }
  /**
   * Handles keyboard navigation in the list.
   *
   * @param event {KeyboardEvent} The keyboard event that triggers this handler.
   */
  handleKeydown(event) {
    const key = event.key;
    if (!isNavigableKey(key)) {
      return;
    }
    const items = this.items;
    if (!items.length) {
      return;
    }
    const activeItemRecord = _List.getActiveItem(items);
    if (activeItemRecord) {
      activeItemRecord.item.active = false;
    }
    event.preventDefault();
    switch (key) {
      case NAVIGABLE_KEYS.ArrowDown:
        this.activateNextItemInternal(items, activeItemRecord);
        break;
      case NAVIGABLE_KEYS.ArrowUp:
        this.activatePreviousItemInternal(items, activeItemRecord);
        break;
      case NAVIGABLE_KEYS.Home:
        _List.activateFirstItem(items);
        break;
      case NAVIGABLE_KEYS.End:
        _List.activateLastItem(items);
        break;
      default:
        break;
    }
  }
  activateNextItemInternal(items, activeItemRecord) {
    if (activeItemRecord) {
      const next = _List.getNextItem(items, activeItemRecord.index);
      if (next)
        next.active = true;
      return next;
    } else {
      return _List.activateFirstItem(items);
    }
  }
  activatePreviousItemInternal(items, activeItemRecord) {
    if (activeItemRecord) {
      const prev = _List.getPrevItem(items, activeItemRecord.index);
      if (prev)
        prev.active = true;
      return prev;
    } else {
      return _List.activateLastItem(items);
    }
  }
  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem() {
    const items = this.items;
    const activeItemRecord = _List.getActiveItem(items);
    if (activeItemRecord) {
      activeItemRecord.item.active = false;
    }
    return this.activateNextItemInternal(items, activeItemRecord);
  }
  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem() {
    const items = this.items;
    const activeItemRecord = _List.getActiveItem(items);
    if (activeItemRecord) {
      activeItemRecord.item.active = false;
    }
    return this.activatePreviousItemInternal(items, activeItemRecord);
  }
  /**
   * Activates the first non-disabled item of a given array of items.
   *
   * @param items {Array<ListItem>} The items from which to activate the
   * first item.
   * @nocollapse
   */
  static activateFirstItem(items) {
    const firstItem = _List.getFirstActivatableItem(items);
    if (firstItem) {
      firstItem.active = true;
    }
    return firstItem;
  }
  /**
   * Activates the last non-disabled item of a given array of items.
   *
   * @param items {Array<ListItem>} The items from which to activate the
   * last item.
   * @nocollapse
   */
  static activateLastItem(items) {
    const lastItem = _List.getLastActivatableItem(items);
    if (lastItem) {
      lastItem.active = true;
    }
    return lastItem;
  }
  /**
   * Deactivates the currently active item of a given array of items.
   *
   * @param items {Array<ListItem>} The items from which to deactivate the
   * active item.
   * @return A record of the deleselcted activated item including the item and
   * the index of the item or `null` if none are deactivated.
   * @nocollapse
   */
  static deactivateActiveItem(items) {
    const activeItem = _List.getActiveItem(items);
    if (activeItem) {
      activeItem.item.active = false;
    }
    return activeItem;
  }
  focus() {
    var _a;
    (_a = this.listRoot) == null ? void 0 : _a.focus();
  }
  /**
   * Retrieves the first activated item of a given array of items.
   *
   * @param items {Array<ListItem>} The items to search.
   * @return A record of the first activated item including the item and the
   * index of the item or `null` if none are activated.
   * @nocollapse
   */
  static getActiveItem(items) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.active) {
        return {
          item,
          index: i
        };
      }
    }
    return null;
  }
  /**
   * Retrieves the first non-disabled item of a given array of items. This
   * the first item that is not disabled.
   *
   * @param items {Array<ListItem>} The items to search.
   * @return The first activatable item or `null` if none are activatable.
   * @nocollapse
   */
  static getFirstActivatableItem(items) {
    for (const item of items) {
      if (!item.disabled) {
        return item;
      }
    }
    return null;
  }
  /**
   * Retrieves the last non-disabled item of a given array of items.
   *
   * @param items {Array<ListItem>} The items to search.
   * @return The last activatable item or `null` if none are activatable.
   * @nocollapse
   */
  static getLastActivatableItem(items) {
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      if (!item.disabled) {
        return item;
      }
    }
    return null;
  }
  /**
   * Retrieves the next non-disabled item of a given array of items.
   *
   * @param items {Array<ListItem>} The items to search.
   * @param index {{index: number}} The index to search from.
   * @return The next activatable item or `null` if none are activatable.
   */
  static getNextItem(items, index) {
    for (let i = 1; i < items.length; i++) {
      const nextIndex = (i + index) % items.length;
      const item = items[nextIndex];
      if (!item.disabled) {
        return item;
      }
    }
    return items[index] ? items[index] : null;
  }
  /**
   * Retrieves the previous non-disabled item of a given array of items.
   *
   * @param items {Array<ListItem>} The items to search.
   * @param index {{index: number}} The index to search from.
   * @return The previous activatable item or `null` if none are activatable.
   */
  static getPrevItem(items, index) {
    for (let i = 1; i < items.length; i++) {
      const prevIndex = (index - i + items.length) % items.length;
      const item = items[prevIndex];
      if (!item.disabled) {
        return item;
      }
    }
    return items[index] ? items[index] : null;
  }
};
(() => {
  requestUpdateOnAriaChange(List);
})();
List.shadowRootOptions = { mode: "open", delegatesFocus: true };
__decorate([
  property()
], List.prototype, "type", void 0);
__decorate([
  property({ type: Number, attribute: "list-tabindex" })
], List.prototype, "listTabIndex", void 0);
__decorate([
  query(".md3-list")
], List.prototype, "listRoot", void 0);
__decorate([
  queryAssignedElements({ flatten: true, selector: "[md-list-item]" })
], List.prototype, "items", void 0);

export {
  List
};
/*! Bundled license information:

@material/web/list/internal/list.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=chunk-GK2LJYQM.js.map
