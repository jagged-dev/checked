{
  "version": 3,
  "sources": ["../../@material/web/select/internal/shared-styles.css.ts", "../../@material/web/menu/internal/forced-colors-styles.css.ts", "../../@material/web/list/internal/list.ts", "../../@material/web/list/internal/list-styles.css.ts", "../../@material/web/list/list.ts", "../../@material/web/menu/internal/surfacePositionController.ts", "../../@material/web/menu/internal/typeaheadController.ts", "../../@material/web/menu/internal/menu.ts", "../../@material/web/menu/internal/menu-styles.css.ts", "../../@material/web/menu/menu.ts", "../../@material/web/select/internal/select.ts"],
  "sourcesContent": ["/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{color:unset;min-width:210px}.field{cursor:default;outline:none}.select{position:relative}.icon.trailing svg,.icon ::slotted(*){fill:currentColor}.icon ::slotted(*){width:inherit;height:inherit;font-size:inherit}.icon slot{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.icon.trailing :is(.up,.down){opacity:0;transition:opacity 75ms linear 75ms}.select:not(.open) .down,.select.open .up{opacity:1}.field,.select,md-menu{min-width:inherit;width:inherit;max-width:inherit}.field,.select{width:100%}:host{display:inline-flex}:host([disabled]){pointer-events:none}/*# sourceMappingURL=shared-styles.css.map */\n`;\n ", "/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}/*# sourceMappingURL=forced-colors-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, LitElement, nothing} from 'lit';\nimport {property, query, queryAssignedElements} from 'lit/decorators.js';\n\nimport {ARIAMixinStrict, ARIARole} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\n\nimport {ListItem} from './listitem/list-item.js';\n\nconst NAVIGABLE_KEYS = {\n  ArrowDown: 'ArrowDown',\n  ArrowUp: 'ArrowUp',\n  Home: 'Home',\n  End: 'End',\n} as const;\n\n/**\n * A record that describes a list item in a list with metadata such a reference\n * to the item and its index in the list.\n */\nexport interface ItemRecord {\n  item: ListItem;\n  index: number;\n}\n\ntype NavigatableValues = typeof NAVIGABLE_KEYS[keyof typeof NAVIGABLE_KEYS];\n\nconst navigableKeySet = new Set(Object.values(NAVIGABLE_KEYS));\n\nfunction isNavigableKey(key: string): key is NavigatableValues {\n  return navigableKeySet.has(key as NavigatableValues);\n}\n\n// tslint:disable-next-line:enforce-comments-on-exported-symbols\nexport class List extends LitElement {\n  static {\n    requestUpdateOnAriaChange(List);\n  }\n\n  /** @nocollapse */\n  static override shadowRootOptions:\n      ShadowRootInit = {mode: 'open', delegatesFocus: true};\n\n  @property() type: ARIARole|'' = 'list';\n\n  /**\n   * The tabindex of the underlying list.\n   */\n  @property({type: Number, attribute: 'list-tabindex'}) listTabIndex = 0;\n\n  @query('.md3-list') private listRoot!: HTMLElement|null;\n\n  /**\n   * An array of activatable and disableable list items. Queries every assigned\n   * element that has the `md-list-item` attribute.\n   *\n   * _NOTE:_ This is a shallow, flattened query via\n   * `HTMLSlotElement.queryAssignedElements` and thus will _only_ include direct\n   * children / directly slotted elements.\n   */\n  @queryAssignedElements({flatten: true, selector: '[md-list-item]'})\n  items!: ListItem[];\n\n  protected override render() {\n    return this.renderList();\n  }\n\n  /**\n   * Renders the main list element.\n   */\n  private renderList() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return html`\n    <ul class=\"md3-list\"\n        aria-label=${ariaLabel || nothing}\n        tabindex=${this.listTabIndex}\n        role=${this.type || nothing}\n        @keydown=${this.handleKeydown}\n        >\n      ${this.renderContent()}\n    </ul>\n  `;\n  }\n\n  /**\n   * The content to be slotted into the list.\n   */\n  private renderContent() {\n    return html`<span><slot @click=${(event: Event) => {\n      event.stopPropagation();\n    }}></slot></span>`;\n  }\n\n  /**\n   * Handles keyboard navigation in the list.\n   *\n   * @param event {KeyboardEvent} The keyboard event that triggers this handler.\n   */\n  private handleKeydown(event: KeyboardEvent) {\n    const key = event.key;\n    if (!isNavigableKey(key)) {\n      return;\n    }\n    // do not use this.items directly so we don't re-query the DOM unnecessarily\n    const items = this.items;\n\n    if (!items.length) {\n      return;\n    }\n\n    const activeItemRecord = List.getActiveItem(items);\n\n    if (activeItemRecord) {\n      activeItemRecord.item.active = false;\n    }\n\n    event.preventDefault();\n\n    switch (key) {\n      // Activate the next item\n      case NAVIGABLE_KEYS.ArrowDown:\n        this.activateNextItemInternal(items, activeItemRecord);\n        break;\n\n      // Activate the previous item\n      case NAVIGABLE_KEYS.ArrowUp:\n        this.activatePreviousItemInternal(items, activeItemRecord);\n        break;\n\n      // Activate the first item\n      case NAVIGABLE_KEYS.Home:\n        List.activateFirstItem(items);\n        break;\n\n      // Activate the last item\n      case NAVIGABLE_KEYS.End:\n        List.activateLastItem(items);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  private activateNextItemInternal(\n      items: ListItem[], activeItemRecord: null|ItemRecord): ListItem|null {\n    if (activeItemRecord) {\n      const next = List.getNextItem(items, activeItemRecord.index);\n\n      if (next) next.active = true;\n\n      return next;\n    } else {\n      return List.activateFirstItem(items);\n    }\n  }\n\n  private activatePreviousItemInternal(\n      items: ListItem[], activeItemRecord: null|ItemRecord): ListItem|null {\n    if (activeItemRecord) {\n      const prev = List.getPrevItem(items, activeItemRecord.index);\n      if (prev) prev.active = true;\n      return prev;\n    } else {\n      return List.activateLastItem(items);\n    }\n  }\n\n  /**\n   * Activates the next item in the list. If at the end of the list, the first\n   * item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activateNextItem(): ListItem|null {\n    const items = this.items;\n    const activeItemRecord = List.getActiveItem(items);\n    if (activeItemRecord) {\n      activeItemRecord.item.active = false;\n    }\n    return this.activateNextItemInternal(items, activeItemRecord);\n  }\n\n  /**\n   * Activates the previous item in the list. If at the start of the list, the\n   * last item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activatePreviousItem(): ListItem|null {\n    const items = this.items;\n    const activeItemRecord = List.getActiveItem(items);\n    if (activeItemRecord) {\n      activeItemRecord.item.active = false;\n    }\n    return this.activatePreviousItemInternal(items, activeItemRecord);\n  }\n\n  /**\n   * Activates the first non-disabled item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items from which to activate the\n   * first item.\n   * @nocollapse\n   */\n  static activateFirstItem<T extends ListItem>(items: T[]) {\n    // NOTE: These selector functions are static and not on the instance such\n    // that multiple operations can be chained and we do not have to re-query\n    // the DOM\n    const firstItem = List.getFirstActivatableItem(items);\n    if (firstItem) {\n      firstItem.active = true;\n    }\n    return firstItem;\n  }\n\n  /**\n   * Activates the last non-disabled item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items from which to activate the\n   * last item.\n   * @nocollapse\n   */\n  static activateLastItem<T extends ListItem>(items: T[]) {\n    const lastItem = List.getLastActivatableItem(items);\n    if (lastItem) {\n      lastItem.active = true;\n    }\n    return lastItem;\n  }\n\n  /**\n   * Deactivates the currently active item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items from which to deactivate the\n   * active item.\n   * @return A record of the deleselcted activated item including the item and\n   * the index of the item or `null` if none are deactivated.\n   * @nocollapse\n   */\n  static deactivateActiveItem<T extends ListItem>(items: T[]) {\n    const activeItem = List.getActiveItem(items);\n    if (activeItem) {\n      activeItem.item.active = false;\n    }\n    return activeItem;\n  }\n\n  override focus() {\n    this.listRoot?.focus();\n  }\n\n  /**\n   * Retrieves the first activated item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items to search.\n   * @return A record of the first activated item including the item and the\n   * index of the item or `null` if none are activated.\n   * @nocollapse\n   */\n  static getActiveItem<T extends ListItem>(items: T[]) {\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      if (item.active) {\n        return {\n          item,\n          index: i,\n        } as ItemRecord;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Retrieves the first non-disabled item of a given array of items. This\n   * the first item that is not disabled.\n   *\n   * @param items {Array<ListItem>} The items to search.\n   * @return The first activatable item or `null` if none are activatable.\n   * @nocollapse\n   */\n  static getFirstActivatableItem<T extends ListItem>(items: T[]) {\n    for (const item of items) {\n      if (!item.disabled) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the last non-disabled item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items to search.\n   * @return The last activatable item or `null` if none are activatable.\n   * @nocollapse\n   */\n  static getLastActivatableItem<T extends ListItem>(items: T[]) {\n    for (let i = items.length - 1; i >= 0; i--) {\n      const item = items[i];\n      if (!item.disabled) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Retrieves the next non-disabled item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items to search.\n   * @param index {{index: number}} The index to search from.\n   * @return The next activatable item or `null` if none are activatable.\n   */\n  private static getNextItem<T extends ListItem>(items: T[], index: number) {\n    for (let i = 1; i < items.length; i++) {\n      const nextIndex = (i + index) % items.length;\n      const item = items[nextIndex];\n      if (!item.disabled) {\n        return item;\n      }\n    }\n\n    return items[index] ? items[index] : null;\n  }\n\n  /**\n   * Retrieves the previous non-disabled item of a given array of items.\n   *\n   * @param items {Array<ListItem>} The items to search.\n   * @param index {{index: number}} The index to search from.\n   * @return The previous activatable item or `null` if none are activatable.\n   */\n  private static getPrevItem<T extends ListItem>(items: T[], index: number) {\n    for (let i = 1; i < items.length; i++) {\n      const prevIndex = (index - i + items.length) % items.length;\n      const item = items[prevIndex];\n\n      if (!item.disabled) {\n        return item;\n      }\n    }\n\n    return items[index] ? items[index] : null;\n  }\n}\n", "/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{--_container-color: var(--md-list-container-color, var(--md-sys-color-surface, #fef7ff));color:unset;display:flex}.md3-list{background-color:var(--_container-color);border-radius:inherit;display:block;list-style-type:none;margin:0;min-width:inherit;outline:none;padding:8px 0;position:relative}/*# sourceMappingURL=list-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {customElement} from 'lit/decorators.js';\n\nimport {List} from './internal/list.js';\nimport {styles} from './internal/list-styles.css.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'md-list': MdList;\n  }\n}\n\n/**\n * @summary Lists are continuous, vertical indexes of text or images.\n *\n * @description\n * Lists consist of one or more list items, and can contain actions represented\n * by icons and text. List items come in three sizes: one-line, two-line, and\n * three-line.\n *\n * __Takeaways:__\n *\n * - Lists should be sorted in logical ways that make content easy to scan, such\n *   as alphabetical, numerical, chronological, or by user preference.\n * - Lists present content in a way that makes it easy to identify a specific\n *   item in a collection and act on it.\n * - Lists should present icons, text, and actions in a consistent format.\n *\n * @final\n * @suppress {visibility}\n */\n@customElement('md-list')\nexport class MdList extends List {\n  static override styles = [styles];\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveController, ReactiveControllerHost} from 'lit';\nimport {StyleInfo} from 'lit/directives/style-map.js';\n\n/**\n * A corner of a box in the standard logical property style of <block>_<inline>\n */\nexport type Corner = 'END_START'|'END_END'|'START_START'|'START_END';\n\n/**\n * An interface that provides a method to customize the rect from which to\n * calculate the anchor positioning. Useful for when you want a surface to\n * anchor to an element in your shadow DOM rather than the host element.\n */\nexport interface SurfacePositionTarget extends HTMLElement {\n  getSurfacePositionClientRect?: () => DOMRect;\n}\n\n/**\n * The configurable options for the surface position controller.\n */\nexport interface SurfacePositionControllerProperties {\n  /**\n   * The corner of the anchor to align the surface's position.\n   */\n  anchorCorner: Corner;\n  /**\n   * The corner of the surface to align to the given anchor corner.\n   */\n  surfaceCorner: Corner;\n  /**\n   * The HTMLElement reference of the surface to be positioned.\n   */\n  surfaceEl: SurfacePositionTarget|null;\n  /**\n   * The HTMLElement reference of the anchor to align to.\n   */\n  anchorEl: SurfacePositionTarget|null;\n  /**\n   * Whether or not the calculation should be relative to the top layer rather\n   * than relative to the parent of the anchor.\n   *\n   * Examples for `isTopLayer:true`:\n   *\n   * - If there is no `position:relative` in the given parent tree and the\n   *   surface is `position:absolute`\n   * - If the surface is `position:fixed`\n   * - If the surface is in the \"top layer\"\n   * - The anchor and the surface do not share a common `position:relative`\n   *   ancestor\n   */\n  isTopLayer: boolean;\n  /**\n   * Whether or not the surface should be \"open\" and visible\n   */\n  isOpen: boolean;\n  /**\n   * The number of pixels in which to offset from the inline axis relative to\n   * logical property.\n   *\n   * Positive is right in LTR and left in RTL.\n   */\n  xOffset: number;\n  /**\n   * The number of pixes in which to offset the block axis.\n   *\n   * Positive is down and negative is up.\n   */\n  yOffset: number;\n  /**\n   * A function to call after the surface has been positioned.\n   */\n  onOpen: () => void;\n  /**\n   * A function to call before the surface should be closed. (A good time to\n   * perform animations while the surface is still visible)\n   */\n  beforeClose: () => Promise<void>;\n  /**\n   * A function to call after the surface has been closed.\n   */\n  onClose: () => void;\n}\n\n/**\n * Given a surface, an anchor, corners, and some options, this surface will\n * calculate the position of a surface to align the two given corners and keep\n * the surface inside the window viewport. It also provides a StyleInfo map that\n * can be applied to the surface to handle visiblility and position.\n */\nexport class SurfacePositionController implements ReactiveController {\n  // The current styles to apply to the surface.\n  private surfaceStylesInternal: StyleInfo = {\n    'display': 'none',\n  };\n  // Previous values stored for change detection. Open change detection is\n  // calculated separately so initialize it here.\n  private lastValues: SurfacePositionControllerProperties = {isOpen: false} as\n      SurfacePositionControllerProperties;\n\n  /**\n   * @param host The host to connect the controller to.\n   * @param getProperties A function that returns the properties for the\n   * controller.\n   */\n  constructor(\n      private readonly host: ReactiveControllerHost,\n      private readonly getProperties: () => SurfacePositionControllerProperties,\n  ) {\n    this.host.addController(this);\n  }\n\n  /**\n   * The StyleInfo map to apply to the surface via Lit's stylemap\n   */\n  get surfaceStyles() {\n    return this.surfaceStylesInternal;\n  }\n\n  /**\n   * Calculates the surface's new position required so that the surface's\n   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the\n   * surface inside the window viewport. This positioning also respects RTL by\n   * checking `getComputedStyle()` on the surface element.\n   */\n  async position() {\n    const {\n      surfaceEl,\n      anchorEl,\n      anchorCorner: anchorCornerRaw,\n      surfaceCorner: surfaceCornerRaw,\n      isTopLayer: topLayerRaw,\n      xOffset,\n      yOffset,\n    } = this.getProperties();\n    const anchorCorner = anchorCornerRaw.toUpperCase().trim();\n    const surfaceCorner = surfaceCornerRaw.toUpperCase().trim();\n\n    if (!surfaceEl || !anchorEl) {\n      return;\n    }\n\n    // Paint the surface transparently so that we can get the position and the\n    // rect info of the surface.\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '0',\n    };\n\n    // Wait for it to be visible.\n    this.host.requestUpdate();\n    await this.host.updateComplete;\n\n    const surfaceRect = surfaceEl.getSurfacePositionClientRect ?\n        surfaceEl.getSurfacePositionClientRect() :\n        surfaceEl.getBoundingClientRect();\n    const anchorRect = anchorEl.getSurfacePositionClientRect ?\n        anchorEl.getSurfacePositionClientRect() :\n        anchorEl.getBoundingClientRect();\n    const [surfaceBlock, surfaceInline] =\n        surfaceCorner.split('_') as Array<'START'|'END'>;\n    const [anchorBlock, anchorInline] =\n        anchorCorner.split('_') as Array<'START'|'END'>;\n\n\n    // We use number booleans to multiply values rather than `if` / ternary\n    // statements because it _heavily_ cuts down on nesting and readability\n    const isTopLayer = topLayerRaw ? 1 : 0;\n    // LTR depends on the direction of the SURFACE not the anchor.\n    const isLTR =\n        getComputedStyle(surfaceEl as HTMLElement).direction === 'ltr' ? 1 : 0;\n    const isRTL = isLTR ? 0 : 1;\n    const isSurfaceInlineStart = surfaceInline === 'START' ? 1 : 0;\n    const isSurfaceInlineEnd = surfaceInline === 'END' ? 1 : 0;\n    const isSurfaceBlockStart = surfaceBlock === 'START' ? 1 : 0;\n    const isSurfaceBlockEnd = surfaceBlock === 'END' ? 1 : 0;\n    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;\n    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;\n\n    /*\n     * A diagram that helps describe some of the variables used in the following\n     * calculations.\n     *\n     * ┌───── inline/blockTopLayerOffset\n     * │       │\n     * │     ┌─▼───┐                  Window\n     * │    ┌┼─────┴────────────────────────┐\n     * │    ││                              │\n     * └──► ││  ┌──inline/blockAnchorOffset │\n     *      ││  │     │                     │\n     *      └┤  │  ┌──▼───┐                 │\n     *       │  │ ┌┼──────┤                 │\n     *       │  └─►│Anchor│                 │\n     *       │    └┴──────┘                 │\n     *       │                              │\n     *       │     ┌────────────────────────┼────┐\n     *       │     │ Surface                │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       └─────┼────────────────────────┘    ├┐\n     *             │ inline/blockOOBCorrection   ││\n     *             │                         │   ││\n     *             │                         ├──►││\n     *             │                         │   ││\n     *             └────────────────────────┐▼───┼┘\n     *                                      └────┘\n     */\n\n    // Whether or not to apply the width of the anchor\n    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;\n    // The inline position of the anchor relative to window in LTR\n    const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left +\n        isSurfaceInlineEnd * (window.innerWidth - anchorRect.right);\n    // The inline position of the anchor relative to window in RTL\n    const inlineTopLayerOffsetRTL =\n        isSurfaceInlineStart * (window.innerWidth - anchorRect.right) +\n        isSurfaceInlineEnd * anchorRect.left;\n    // The inline position of the anchor relative to window\n    const inlineTopLayerOffset =\n        isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;\n    // If the surface's inline would be out of bounds of the window, move it\n    // back in\n    const inlineOutOfBoundsCorrection = Math.min(\n        0,\n        window.innerWidth - inlineTopLayerOffset - inlineAnchorOffset -\n            surfaceRect.width);\n\n    // The inline logical value of the surface\n    const inline = isTopLayer * inlineTopLayerOffset + inlineAnchorOffset +\n        inlineOutOfBoundsCorrection;\n\n    // Whether or not to apply the height of the anchor\n    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;\n    // The absolute block position of the anchor relative to window\n    const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top +\n        isSurfaceBlockEnd * (window.innerHeight - anchorRect.bottom);\n    // If the surface's block would be out of bounds of the window, move it back\n    // in\n    const blockOutOfBoundsCorrection = Math.min(\n        0,\n        window.innerHeight - blockTopLayerOffset - blockAnchorOffset -\n            surfaceRect.height);\n\n    // The block logical value of the surface\n    const block = isTopLayer * blockTopLayerOffset + blockAnchorOffset +\n        blockOutOfBoundsCorrection;\n\n    const surfaceBlockProperty =\n        surfaceBlock === 'START' ? 'inset-block-start' : 'inset-block-end';\n    const surfaceInlineProperty =\n        surfaceInline === 'START' ? 'inset-inline-start' : 'inset-inline-end';\n\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '1',\n      [surfaceBlockProperty]: `${block}px`,\n      [surfaceInlineProperty]: `${inline}px`,\n    };\n\n    this.host.requestUpdate();\n  }\n\n  hostUpdate() {\n    this.onUpdate();\n  }\n\n  hostUpdated() {\n    this.onUpdate();\n  }\n\n  /**\n   * Checks whether the properties passed into the controller have changed since\n   * the last positioning. If so, it will reposition if the surface is open or\n   * close it if the surface should close.\n   */\n  private async onUpdate() {\n    const props = this.getProperties();\n    let hasChanged = false;\n    for (const [key, value] of Object.entries(props)) {\n      // tslint:disable-next-line\n      hasChanged = hasChanged || (value !== (this.lastValues as any)[key]);\n      if (hasChanged) break;\n    }\n\n    const openChanged = this.lastValues.isOpen !== props.isOpen;\n    const hasAnchor = !!props.anchorEl;\n    const hasSurface = !!props.surfaceEl;\n\n    if (hasChanged && hasAnchor && hasSurface) {\n      // Only update isOpen, because if it's closed, we do not want to waste\n      // time on a useless reposition calculation. So save the other \"dirty\"\n      // values until next time it opens.\n      this.lastValues.isOpen = props.isOpen;\n\n      if (props.isOpen) {\n        // We are going to do a reposition, so save the prop values for future\n        // dirty checking.\n        this.lastValues = props;\n\n        await this.position();\n        props.onOpen();\n      } else if (openChanged) {\n        await props.beforeClose();\n        this.close();\n        props.onClose();\n      }\n    }\n  }\n\n  /**\n   * Hides the surface.\n   */\n  private close() {\n    this.surfaceStylesInternal = {\n      'display': 'none',\n    };\n    this.host.requestUpdate();\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {MenuItem} from './shared.js';\n\n/**\n * The options that are passed to the typeahead controller.\n */\nexport interface TypeaheadControllerProperties {\n  /**\n   * A function that returns an array of menu items to be searched.\n   * @return An array of menu items to be searched by typing.\n   */\n  getItems: () => MenuItem[];\n  /**\n   * The maximum time between each keystroke to keep the current type buffer\n   * alive.\n   */\n  typeaheadBufferTime: number;\n  /**\n   * Whether or not the typeahead should listen for keystrokes or not.\n   */\n  active: boolean;\n}\n\n/**\n * Data structure tuple that helps with indexing.\n *\n * [index, item, normalized header text]\n */\ntype TypeaheadRecord = [number, MenuItem, string];\n/**\n * Indicies to access the TypeaheadRecord tuple type.\n */\nexport const TYPEAHEAD_RECORD = {\n  INDEX: 0,\n  ITEM: 1,\n  TEXT: 2,\n} as const;\n\n/**\n * This controller listens to `keydown` events and searches the header text of\n * an array of `MenuItem`s with the corresponding entered keys within the buffer\n * time and activates the item.\n *\n * @example\n * ```ts\n * const typeaheadController = new TypeaheadController(() => ({\n *   typeaheadBufferTime: 50,\n *   getItems: () => Array.from(document.querySelectorAll('md-menu-item'))\n * }));\n * html`\n *   <div\n *       @keydown=${typeaheadController.onKeydown}\n *       tabindex=\"0\"\n *       class=\"activeItemText\">\n *     <!-- focusable element that will receive keydown events -->\n *     Apple\n *   </div>\n *   <div>\n *     <md-menu-item active header=\"Apple\"></md-menu-item>\n *     <md-menu-item header=\"Apricot\"></md-menu-item>\n *     <md-menu-item header=\"Banana\"></md-menu-item>\n *     <md-menu-item header=\"Olive\"></md-menu-item>\n *     <md-menu-item header=\"Orange\"></md-menu-item>\n *   </div>\n * `;\n * ```\n */\nexport class TypeaheadController {\n  /**\n   * Array of tuples that helps with indexing.\n   */\n  private typeaheadRecords: TypeaheadRecord[] = [];\n  /**\n   * Currently-typed text since last buffer timeout\n   */\n  private typaheadBuffer = '';\n  /**\n   * The timeout id from the current buffer's setTimeout\n   */\n  private cancelTypeaheadTimeout = 0;\n  /**\n   * If we are currently \"typing\"\n   */\n  isTypingAhead = false;\n  /**\n   * The record of the last active item.\n   */\n  lastActiveRecord: TypeaheadRecord|null = null;\n\n  /**\n   * @param getProperties A function that returns the options of the typeahead\n   * controller:\n   *\n   * {\n   *   getItems: A function that returns an array of menu items to be searched.\n   *   typeaheadBufferTime: The maximum time between each keystroke to keep the\n   *       current type buffer alive.\n   * }\n   */\n  constructor(\n      private readonly getProperties: () => TypeaheadControllerProperties,\n  ) {}\n\n  private get items() {\n    return this.getProperties().getItems();\n  }\n\n  private get active() {\n    return this.getProperties().active;\n  }\n\n  /**\n   * Apply this listener to the element that will receive `keydown` events that\n   * should trigger this controller.\n   *\n   * @param event The native browser `KeyboardEvent` from the `keydown` event.\n   */\n  readonly onKeydown = (event: KeyboardEvent) => {\n    if (this.isTypingAhead) {\n      this.typeahead(event);\n    } else {\n      this.beginTypeahead(event);\n    }\n  };\n\n  /**\n   * Sets up typingahead\n   */\n  private beginTypeahead(event: KeyboardEvent) {\n    if (!this.active) {\n      return;\n    }\n\n    // We don't want to typeahead if the _beginning_ of the typeahead is a menu\n    // navigation, or a selection. We will handle \"Space\" only if it's in the\n    // middle of a typeahead\n    if (event.code === 'Space' || event.code === 'Enter' ||\n        event.code.startsWith('Arrow') || event.code === 'Escape') {\n      return;\n    }\n\n    this.isTypingAhead = true;\n    // Generates the record array data structure which is the index, the element\n    // and a normalized header.\n    this.typeaheadRecords = this.items.map(\n        (el, index) => [index, el, el.headline.trim().toLowerCase()]);\n    this.lastActiveRecord =\n        this.typeaheadRecords.find(\n            record => record[TYPEAHEAD_RECORD.ITEM].active) ??\n        null;\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n    }\n    this.typeahead(event);\n  }\n\n  /**\n   * Performs the typeahead. Based on the normalized items and the current text\n   * buffer, finds the _next_ item with matching text and activates it.\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: 'o'\n   * user types: l\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Orange\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange (active), Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   */\n  private typeahead(event: KeyboardEvent) {\n    clearTimeout(this.cancelTypeaheadTimeout);\n    // Stop typingahead if one of the navigation or selection keys (except for\n    // Space) are pressed\n    if (event.code === 'Enter' || event.code.startsWith('Arrow') ||\n        event.code === 'Escape') {\n      this.endTypeahead();\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n      }\n      return;\n    }\n\n    // If Space is pressed, prevent it from selecting and closing the menu\n    if (event.code === 'Space') {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n\n    // Start up a new keystroke buffer timeout\n    this.cancelTypeaheadTimeout =\n        setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);\n\n    this.typaheadBuffer += event.key.toLowerCase();\n\n    const lastActiveIndex = this.lastActiveRecord ?\n        this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] :\n        -1;\n    const numRecords = this.typeaheadRecords.length;\n\n    /**\n     * Sorting function that will resort the items starting with the given index\n     *\n     * @example\n     *\n     * this.typeaheadRecords =\n     * 0: [0, <reference>, 'apple']\n     * 1: [1, <reference>, 'apricot']\n     * 2: [2, <reference>, 'banana']\n     * 3: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 4: [4, <reference>, 'orange']\n     * 5: [5, <reference>, 'strawberry']\n     *\n     * this.typeaheadRecords.sort((a,b) => rebaseIndexOnActive(a)\n     *                                       - rebaseIndexOnActive(b)) ===\n     * 0: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 1: [4, <reference>, 'orange']\n     * 2: [5, <reference>, 'strawberry']\n     * 3: [0, <reference>, 'apple']\n     * 4: [1, <reference>, 'apricot']\n     * 5: [2, <reference>, 'banana']\n     */\n    const rebaseIndexOnActive = (record: TypeaheadRecord) => {\n      return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) %\n          numRecords;\n    };\n\n    // records filtered and sorted / rebased around the last active index\n    const matchingRecords =\n        this.typeaheadRecords\n            .filter(\n                record => !record[TYPEAHEAD_RECORD.ITEM].disabled &&\n                    record[TYPEAHEAD_RECORD.TEXT].startsWith(\n                        this.typaheadBuffer))\n            .sort((a, b) => rebaseIndexOnActive(a) - rebaseIndexOnActive(b));\n\n    // Just leave if there's nothing that matches. Native select will just\n    // choose the first thing that starts with the next letter in the alphabet\n    // but that's out of scope and hard to localize\n    if (matchingRecords.length === 0) {\n      clearTimeout(this.cancelTypeaheadTimeout);\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n      }\n      this.endTypeahead();\n      return;\n    }\n\n    const isNewQuery = this.typaheadBuffer.length === 1;\n    let nextRecord: TypeaheadRecord;\n\n    // This is likely the case that someone is trying to \"tab\" through different\n    // entries that start with the same letter\n    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {\n      nextRecord = matchingRecords[1] ?? matchingRecords[0];\n    } else {\n      nextRecord = matchingRecords[0];\n    }\n\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].active = false;\n    }\n\n    this.lastActiveRecord = nextRecord;\n    nextRecord[TYPEAHEAD_RECORD.ITEM].active = true;\n    return;\n  }\n\n  /**\n   * Ends the current typeahead and clears the buffer.\n   */\n  private readonly endTypeahead = () => {\n    this.isTypingAhead = false;\n    this.typaheadBuffer = '';\n    this.typeaheadRecords = [];\n  };\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../list/list.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../elevation/elevation.js';\n\nimport {html, isServer, LitElement, nothing} from 'lit';\nimport {eventOptions, property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {ARIAMixinStrict, ARIARole} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {createAnimationSignal, EASING} from '../../internal/motion/animation.js';\nimport {List} from '../../list/internal/list.js';\n\nimport {ActivateTypeaheadEvent, DeactivateTypeaheadEvent, isClosableKey, isElementInSubtree, MenuItem} from './shared.js';\nimport {Corner, SurfacePositionController, SurfacePositionTarget} from './surfacePositionController.js';\nimport {TypeaheadController} from './typeaheadController.js';\n\nexport {Corner} from './surfacePositionController.js';\n\n/**\n * The default value for the typeahead buffer time in Milliseconds.\n */\nexport const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;\n\n/**\n * Element to focus on when menu is first opened.\n */\nexport type DefaultFocusState = 'NONE'|'LIST_ROOT'|'FIRST_ITEM'|'LAST_ITEM';\n\n/**\n * Gets the currently focused element on the page.\n *\n * @param activeDoc The document or shadowroot from which to start the search.\n *    Defaults to `window.document`\n * @return Returns the currently deeply focused element or `null` if none.\n */\nfunction getFocusedElement(activeDoc: Document|ShadowRoot = document):\n    HTMLElement|null {\n  const activeEl = activeDoc.activeElement as HTMLElement | null;\n\n  if (!activeEl) {\n    return null;\n  }\n\n  if (activeEl.shadowRoot) {\n    return getFocusedElement(activeEl.shadowRoot) ?? activeEl;\n  }\n\n  return activeEl;\n}\n\n/**\n * @fires opening Fired before the opening animation begins\n * @fires opened Fired once the menu is open, after any animations\n * @fires closing Fired before the closing animation begins\n * @fires closed Fired once the menu is closed, after any animations\n */\nexport abstract class Menu extends LitElement {\n  static {\n    requestUpdateOnAriaChange(Menu);\n  }\n\n  @query('md-list') private readonly listElement!: List|null;\n  @query('.menu') private readonly surfaceEl!: HTMLElement|null;\n  @query('slot') private readonly slotEl!: HTMLSlotElement|null;\n\n  /**\n   * The element in which the menu should align to.\n   */\n  @property({attribute: false})\n  anchor: HTMLElement&Partial<SurfacePositionTarget>|null = null;\n  /**\n   * Makes the element use `position:fixed` instead of `position:absolute`. In\n   * most cases, the menu should position itself above most other\n   * `position:absolute` or `position:fixed` elements when placed inside of\n   * them. e.g. using a menu inside of an `md-dialog`.\n   *\n   * __NOTE__: Fixed menus will not scroll with the page and will be fixed to\n   * the window instead.\n   */\n  @property({type: Boolean}) fixed = false;\n  /**\n   * Skips the opening and closing animations.\n   */\n  @property({type: Boolean}) quick = false;\n  /**\n   * Displays overflow content like a submenu.\n   *\n   * __NOTE__: This may cause adverse effects if you set\n   * `md-menu {max-height:...}`\n   * and have items overflowing items in the \"y\" direction.\n   */\n  @property({type: Boolean, attribute: 'has-overflow'}) hasOverflow = false;\n  /**\n   * Opens the menu and makes it visible. Alternative to the `.show()` and\n   * `.close()` methods\n   */\n  @property({type: Boolean, reflect: true}) open = false;\n  /**\n   * Offsets the menu's inline alignment from the anchor by the given number in\n   * pixels. This value is direction aware and will follow the LTR / RTL\n   * direction.\n   *\n   * e.g. LTR: positive -> right, negative -> left\n   *      RTL: positive -> left, negative -> right\n   */\n  @property({type: Number, attribute: 'x-offset'}) xOffset = 0;\n  /**\n   * Offsets the menu's block alignment from the anchor by the given number in\n   * pixels.\n   *\n   * e.g. positive -> down, negative -> up\n   */\n  @property({type: Number, attribute: 'y-offset'}) yOffset = 0;\n  /**\n   * The tabindex of the underlying list element.\n   */\n  @property({type: Number, attribute: 'list-tabindex'}) listTabIndex = 0;\n  /**\n   * The role of the underlying list element.\n   */\n  @property() type: ARIARole = 'menu';\n  /**\n   * The max time between the keystrokes of the typeahead menu behavior before\n   * it clears the typeahead buffer.\n   */\n  @property({type: Number, attribute: 'typeahead-delay'})\n  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n  /**\n   * The corner of the anchor which to align the menu in the standard logical\n   * property style of <block>_<inline>.\n   */\n  @property({attribute: 'anchor-corner'}) anchorCorner: Corner = 'END_START';\n  /**\n   * The corner of the menu which to align the anchor in the standard logical\n   * property style of <block>_<inline>.\n   */\n  @property({attribute: 'menu-corner'}) menuCorner: Corner = 'START_START';\n  /**\n   * Keeps the user clicks outside the menu.\n   *\n   * NOTE: clicking outside may still cause focusout to close the menu so see\n   * `stayOpenOnFocusout`.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-outside-click'})\n  stayOpenOnOutsideClick = false;\n  /**\n   * Keeps the menu open when focus leaves the menu's composed subtree.\n   *\n   * NOTE: Focusout behavior will stop propagation of the focusout event. Set\n   * this property to true to opt-out of menu's focuout handling altogether.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-focusout'})\n  stayOpenOnFocusout = false;\n  /**\n   * After closing, does not restore focus to the last focused element before\n   * the menu was opened.\n   */\n  @property({type: Boolean, attribute: 'skip-restore-focus'})\n  skipRestoreFocus = false;\n  /**\n   * The element that should be focused by default once opened.\n   */\n  @property({attribute: 'default-focus'})\n  defaultFocus: DefaultFocusState = 'LIST_ROOT';\n\n  @state() private typeaheadActive = true;\n\n  private readonly openCloseAnimationSignal = createAnimationSignal();\n\n  /**\n   * Whether the menu is animating upwards or downwards when opening. This is\n   * helpful for calculating some animation calculations.\n   */\n  private get openDirection(): 'UP'|'DOWN' {\n    const menuCornerBlock = this.menuCorner.split('_')[0];\n    return menuCornerBlock === 'START' ? 'DOWN' : 'UP';\n  }\n\n  /**\n   * The element that was focused before the menu opened.\n   */\n  private lastFocusedElement: HTMLElement|null = null;\n\n  /**\n   * Handles typeahead navigation through the menu.\n   */\n  typeaheadController = new TypeaheadController(() => {\n    return {\n      getItems: () => this.items,\n      typeaheadBufferTime: this.typeaheadDelay,\n      active: this.typeaheadActive\n    };\n  });\n\n  /**\n   * Handles positioning the surface and aligning it to the anchor.\n   */\n  private readonly menuPositionController =\n      new SurfacePositionController(this, () => {\n        return {\n          anchorCorner: this.anchorCorner,\n          surfaceCorner: this.menuCorner,\n          surfaceEl: this.surfaceEl,\n          anchorEl: this.anchor,\n          isTopLayer: this.fixed,\n          isOpen: this.open,\n          xOffset: this.xOffset,\n          yOffset: this.yOffset,\n          onOpen: this.onOpened,\n          beforeClose: this.beforeClose,\n          onClose: this.onClosed,\n        };\n      });\n\n  /**\n   * The menu items associated with this menu. The items must be `MenuItem`s and\n   * have both the `md-menu-item` and `md-list-item` attributes.\n   */\n  get items(): MenuItem[] {\n    const listElement = this.listElement;\n\n    if (listElement) {\n      return listElement.items.filter(el => el.hasAttribute('md-menu-item')) as\n          MenuItem[];\n    }\n\n    return [];\n  }\n\n  protected override render() {\n    return this.renderSurface();\n  }\n\n  /**\n   * Renders the positionable surface element and its contents.\n   */\n  private renderSurface() {\n    // TODO(b/274140618): elevation should be an underlay, not an overlay that\n    // tints content\n    return html`\n       <div\n          class=\"menu ${classMap(this.getSurfaceClasses())}\"\n          style=${styleMap(this.menuPositionController.surfaceStyles)}\n          @focusout=${this.handleFocusout}>\n        ${this.renderElevation()}\n        ${this.renderList()}\n        ${this.renderFocusRing()}\n       </div>\n     `;\n  }\n\n  /**\n   * Renders the List element and its items\n   */\n  private renderList() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return html`\n      <md-list\n          part=\"list\"\n          id=\"list\"\n          aria-label=${ariaLabel || nothing}\n          type=${this.type}\n          listTabIndex=${this.listTabIndex}\n          @keydown=${this.handleListKeydown}>\n        ${this.renderMenuItems()}\n      </md-list>`;\n  }\n\n  /**\n   * Renders the menu items' slot\n   */\n  private renderMenuItems() {\n    return html`<slot\n        @close-menu=${this.onCloseMenu}\n        @deactivate-items=${this.onDeactivateItems}\n        @deactivate-typeahead=${this.handleDeactivateTypeahead}\n        @activate-typeahead=${this.handleActivateTypeahead}\n        @stay-open-on-focusout=${this.handleStayOpenOnFocusout}\n        @close-on-focusout=${this.handleCloseOnFocusout}></slot>`;\n  }\n\n  /**\n   * Renders the elevation component.\n   */\n  private renderElevation() {\n    return html`<md-elevation part=\"elevation\"></md-elevation>`;\n  }\n\n  /**\n   * Renders the focus ring component.\n   */\n  private renderFocusRing() {\n    return html`<md-focus-ring part=\"focus-ring\" for=\"list\"></md-focus-ring>`;\n  }\n\n  private getSurfaceClasses() {\n    return {\n      open: this.open,\n      fixed: this.fixed,\n      'has-overflow': this.hasOverflow,\n    };\n  }\n\n  private async handleFocusout(event: FocusEvent) {\n    if (this.stayOpenOnFocusout) {\n      return;\n    }\n\n    // Stop propagation to prevent nested menus from interfering with each other\n    event.stopPropagation();\n\n    if (event.relatedTarget) {\n      // Don't close the menu if we are switching focus between menu,\n      // md-menu-item, and md-list\n      if (isElementInSubtree(event.relatedTarget, this)) {\n        return;\n      }\n    }\n\n    const oldRestoreFocus = this.skipRestoreFocus;\n    // allow focus to continue to the next focused object rather than returning\n    this.skipRestoreFocus = true;\n    this.close();\n    // await for close\n    await this.updateComplete;\n    // return to previous behavior\n    this.skipRestoreFocus = oldRestoreFocus;\n  }\n\n  // Capture so that we can grab the event before it reaches the list item\n  // istelf. Specifically useful for the case where typeahead encounters a space\n  // and we don't want the menu item to close the menu.\n  @eventOptions({capture: true})\n  private handleListKeydown(event: KeyboardEvent) {\n    if (event.target === this.listElement && !event.defaultPrevented &&\n        isClosableKey(event.code)) {\n      event.preventDefault();\n      this.close();\n    }\n\n    this.typeaheadController.onKeydown(event);\n  }\n\n  /**\n   * Saves the last focused element focuses the new element based on\n   * `defaultFocus`, and animates open.\n   */\n  private readonly onOpened = () => {\n    this.lastFocusedElement = getFocusedElement();\n\n    if (!this.listElement) return;\n\n    const items = this.listElement.items;\n    const activeItemRecord = List.getActiveItem(items);\n\n    if (activeItemRecord && this.defaultFocus !== 'NONE') {\n      activeItemRecord.item.active = false;\n    }\n\n    switch (this.defaultFocus) {\n      case 'FIRST_ITEM':\n        const first = List.getFirstActivatableItem(items);\n        if (first) {\n          first.active = true;\n        }\n        break;\n      case 'LAST_ITEM':\n        const last = List.getLastActivatableItem(items);\n        if (last) {\n          last.active = true;\n        }\n        break;\n      case 'LIST_ROOT':\n        this.listElement?.focus();\n        break;\n      default:\n      case 'NONE':\n        // Do nothing.\n        break;\n    }\n\n    if (this.quick) {\n      this.dispatchEvent(new Event('opening'));\n      this.dispatchEvent(new Event('opened'));\n    } else {\n      this.animateOpen();\n    }\n  };\n\n  /**\n   * Animates closed.\n   */\n  private readonly beforeClose = async () => {\n    this.open = false;\n\n    if (!this.skipRestoreFocus) {\n      this.lastFocusedElement?.focus?.();\n    }\n\n    if (!this.quick) {\n      await this.animateClose();\n    }\n  };\n\n  /**\n   * Focuses the last focused element.\n   */\n  private readonly onClosed = () => {\n    if (this.quick) {\n      this.dispatchEvent(new Event('closing'));\n      this.dispatchEvent(new Event('closed'));\n    }\n  };\n\n  /**\n   * Performs the opening animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   */\n  private animateOpen() {\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) return;\n\n    const openDirection = this.openDirection;\n    this.dispatchEvent(new Event('opening'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const openingUpwards = openDirection === 'UP';\n    const children = this.items;\n    const FULL_DURATION = 500;\n    const SURFACE_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_DURATION = 250;\n    // We want to fit every child fade-in animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;\n\n    const surfaceHeightAnimation =\n        surfaceEl.animate([{height: '0px'}, {height: `${height}px`}], {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED,\n        });\n    // When we are opening upwards, we want to make sure the last item is always\n    // in view, so we need to translate it upwards the opposite direction of the\n    // height animation\n    const upPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: openingUpwards ? `translateY(-${height}px)` : ''},\n          {transform: ''}\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 0}, {opacity: 1}], SURFACE_OPACITY_DURATION);\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If we are animating upwards, then reverse the children list.\n      const directionalIndex = openingUpwards ? children.length - 1 - i : i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 0}, {opacity: 1}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make them all initially hidden and then clean up at the end of each\n      // animation.\n      child.classList.toggle('md-menu-hidden', true);\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('md-menu-hidden', false);\n      });\n\n      childrenAnimations.push([child, animation]);\n    }\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      upPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        child.classList.toggle('md-menu-hidden', false);\n        animation.cancel();\n      });\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      this.openCloseAnimationSignal.finish();\n      this.dispatchEvent(new Event('opened'));\n    });\n  }\n\n  /**\n   * Performs the closing animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   */\n  private animateClose() {\n    let resolve!: (value: unknown) => void;\n    let reject!: () => void;\n\n    // This promise blocks the surface position controller from setting\n    // display: none on the surface which will interfere with this animation.\n    const animationEnded = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) {\n      reject();\n      return animationEnded;\n    }\n\n    const openDirection = this.openDirection;\n    const closingDownwards = openDirection === 'UP';\n    this.dispatchEvent(new Event('closing'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const children = this.items;\n    const FULL_DURATION = 150;\n    const SURFACE_OPACITY_DURATION = 50;\n    // The surface fades away at the very end\n    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;\n    const ITEM_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_INITIAL_DELAY = 50;\n    const END_HEIGHT_PERCENTAGE = .35;\n\n    // We want to fit every child fade-out animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) /\n        children.length;\n\n    // The mock has the animation shrink to 35%\n    const surfaceHeightAnimation = surfaceEl.animate(\n        [\n          {height: `${height}px`},\n          {height: `${height * END_HEIGHT_PERCENTAGE}px`}\n        ],\n        {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED_ACCELERATE,\n        });\n\n    // When we are closing downwards, we want to make sure the last item is\n    // always in view, so we need to translate it upwards the opposite direction\n    // of the height animation\n    const downPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: ''}, {\n            transform: closingDownwards ?\n                `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` :\n                ''\n          }\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 1}, {opacity: 0}],\n        {duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY});\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If the animation is closing upwards, then reverse the list of\n      // children so that we animate in the opposite direction.\n      const directionalIndex = closingDownwards ? i : children.length - 1 - i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 1}, {opacity: 0}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make sure the items stay hidden at the end of each child animation.\n      // We clean this up at the end of the overall animation.\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('md-menu-hidden', true);\n      });\n      childrenAnimations.push([child, animation]);\n    }\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      downPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        animation.cancel();\n        child.classList.toggle('md-menu-hidden', false);\n      });\n      reject();\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      childrenAnimations.forEach(([child]) => {\n        child.classList.toggle('md-menu-hidden', false);\n      });\n      this.openCloseAnimationSignal.finish();\n      this.dispatchEvent(new Event('closed'));\n      resolve(true);\n    });\n\n    return animationEnded;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    if (!isServer) {\n      window.addEventListener('click', this.onWindowClick, {capture: true});\n    }\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    if (!isServer) {\n      window.removeEventListener('click', this.onWindowClick, {capture: true});\n    }\n  }\n\n  private readonly onWindowClick = (event: MouseEvent) => {\n    if (!this.stayOpenOnOutsideClick && !event.composedPath().includes(this)) {\n      this.open = false;\n    }\n  };\n\n  private onCloseMenu() {\n    this.close();\n  }\n\n  private onDeactivateItems(event: Event) {\n    event.stopPropagation();\n    const items = this.items;\n    for (const item of items) {\n      item.active = false;\n      item.selected = false;\n    }\n  }\n\n  private handleDeactivateTypeahead(event: DeactivateTypeaheadEvent) {\n    // stopPropagation so that this does not deactivate any typeaheads in menus\n    // nested above it e.g. md-sub-menu-item\n    event.stopPropagation();\n    this.typeaheadActive = false;\n  }\n\n  private handleActivateTypeahead(event: ActivateTypeaheadEvent) {\n    // stopPropagation so that this does not activate any typeaheads in menus\n    // nested above it e.g. md-sub-menu-item\n    event.stopPropagation();\n    this.typeaheadActive = true;\n  }\n\n  private handleStayOpenOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = true;\n  }\n\n  private handleCloseOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = false;\n  }\n\n  override focus() {\n    this.listElement?.focus();\n  }\n\n  close() {\n    this.open = false;\n    this.items.forEach(item => {\n      item.close?.();\n    });\n  }\n\n  show() {\n    this.open = true;\n  }\n\n  /**\n   * Activates the next item in the menu. If at the end of the menu, the first\n   * item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activateNextItem() {\n    return this.listElement?.activateNextItem() as MenuItem ?? null;\n  }\n\n  /**\n   * Activates the previous item in the menu. If at the start of the menu, the\n   * last item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activatePreviousItem() {\n    return this.listElement?.activatePreviousItem() as MenuItem ?? null;\n  }\n}\n", "/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{--_container-color: var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));--_container-elevation: var(--md-menu-container-elevation, 2);--_container-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-shape: var(--md-menu-container-shape, 4px);--md-list-container-color: var(--_container-color);--md-elevation-level: var(--_container-elevation);--md-elevation-shadow-color: var(--_container-shadow-color);min-width:300px}md-focus-ring{--md-focus-ring-shape: var(--_container-shape)}.menu{border-radius:var(--_container-shape);display:none;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit}.menu.fixed{position:fixed}.menu md-list{height:inherit;max-height:inherit;display:block;overflow:auto;min-width:inherit;border-radius:inherit}.menu.has-overflow md-list{overflow:visible}.menu.animating md-list{pointer-events:none;overflow:hidden}.menu.animating ::slotted(.md-menu-hidden){opacity:0}.menu slot{display:block;height:inherit;max-height:inherit}/*# sourceMappingURL=menu-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {customElement} from 'lit/decorators.js';\n\nimport {styles as forcedColors} from './internal/forced-colors-styles.css.js';\nimport {Menu} from './internal/menu.js';\nimport {styles} from './internal/menu-styles.css.js';\n\nexport {ListItem} from '../list/internal/listitem/list-item.js';\nexport {Corner, DefaultFocusState} from './internal/menu.js';\nexport {CloseMenuEvent, MenuItem} from './internal/shared.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'md-menu': MdMenu;\n  }\n}\n\n/**\n * @summary Menus display a list of choices on a temporary surface.\n *\n * @description\n * Menus appear when users interact with a button, action, or other control.\n *\n * They can be opened from a variety of elements, most commonly icon buttons,\n * buttons, and text fields.\n *\n * md-menu listens for the `close-menu` and `deselect-items` events.\n *\n * - `close-menu` closes the menu when dispatched from a child element.\n * - `deselect-items` deselects all of its immediate menu-item children.\n *\n * @example\n * ```html\n * <div style=\"position:relative;\">\n *   <button\n *       class=\"anchor\"\n *       ${ref(anchorRef)}\n *       @click=${() => this.menuRef.value.show()}>\n *     Click to open menu\n *   </button>\n *   <!--\n *     `has-overflow` is required when using a submenu which overflows the\n *     menu's contents\n *   -->\n *   <md-menu has-overflow ${ref(menuRef)} ${(el) => el.anchor =\n * anchorRef.value}> <md-menu-item header=\"This is a header\"></md-menu-item>\n *     <md-sub-menu-item header=\"this is a submenu item\">\n *       <md-menu slot=\"submenu\">\n *         <md-menu-item\n *           header=\"This is an item inside a submenu\"></md-menu-item>\n *       </md-menu>\n *     </md-sub-menu-item>\n *   </md-menu>\n * </div>\n * ```\n *\n * @final\n * @suppress {visibility}\n */\n@customElement('md-menu')\nexport class MdMenu extends Menu {\n  static override styles = [styles, forcedColors];\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../menu/menu.js';\n\nimport {html, LitElement, PropertyValues} from 'lit';\nimport {property, query, queryAssignedElements, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {html as staticHtml, StaticValue} from 'lit/static-html.js';\n\nimport {Field} from '../../field/internal/field.js';\nimport {List} from '../../list/internal/list.js';\nimport {DEFAULT_TYPEAHEAD_BUFFER_TIME, Menu} from '../../menu/internal/menu.js';\nimport {CloseMenuEvent, isElementInSubtree, isSelectableKey} from '../../menu/internal/shared.js';\nimport {TYPEAHEAD_RECORD} from '../../menu/internal/typeaheadController.js';\n\nimport {createRequestDeselectionEvent, createRequestSelectionEvent, getSelectedItems, SelectOption, SelectOptionRecord} from './shared.js';\n\nconst VALUE = Symbol('value');\n\n/**\n * @fires input Fired when a selection is made by the user via mouse or keyboard\n * interaction.\n * @fires change Fired when a selection is made by the user via mouse or\n * keyboard interaction.\n */\nexport abstract class Select extends LitElement {\n  /**\n   * Opens the menu synchronously with no animation.\n   */\n  @property({type: Boolean}) quick = false;\n  /**\n   * Whether or not the select is required.\n   */\n  @property({type: Boolean}) required = false;\n  /**\n   * Disables the select.\n   */\n  @property({type: Boolean, reflect: true}) disabled = false;\n  /**\n   * The error message that replaces supporting text when `error` is true. If\n   * `errorText` is an empty string, then the supporting text will continue to\n   * show.\n   *\n   * Calling `reportValidity()` will automatically update `errorText` to the\n   * native `validationMessage`.\n   */\n  @property({type: String, attribute: 'error-text'}) errorText = '';\n  /**\n   * The floating label for the field.\n   */\n  @property() label = '';\n  /**\n   * Conveys additional information below the text field, such as how it should\n   * be used.\n   */\n  @property({type: String, attribute: 'supporting-text'}) supportingText = '';\n  /**\n   * Gets or sets whether or not the text field is in a visually invalid state.\n   *\n   * Calling `reportValidity()` will automatically update `error`.\n   */\n  @property({type: Boolean, reflect: true}) error = false;\n  /**\n   * Whether or not the underlying md-menu should be position: fixed to display\n   * in a top-level manner.\n   */\n  @property({type: Boolean, attribute: 'menu-fixed'}) menuFixed = false;\n  /**\n   * The max time between the keystrokes of the typeahead select / menu behavior\n   * before it clears the typeahead buffer.\n   */\n  @property({type: Number, attribute: 'typeahead-delay'})\n  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n  /**\n   * Whether or not the text field has a leading icon. Used for SSR.\n   */\n  @property({type: Boolean, attribute: 'has-leading-icon'})\n  hasLeadingIcon = false;\n  /**\n   * Text to display in the field. Only set for SSR.\n   */\n  @property({attribute: 'display-text'}) displayText = '';\n\n  @state() private focused = false;\n  @state() private open = false;\n  @query('.field') private readonly field!: Field|null;\n  @query('md-menu') private readonly menu!: Menu|null;\n  @queryAssignedElements({slot: 'leadingicon', flatten: true})\n  private readonly leadingIcons!: Element[];\n\n  /**\n   * The value of the currently selected option.\n   *\n   * Note: For SSR, set `[selected]` on the requested option and `displayText`\n   * rather than setting `value` setting `value` will incur a DOM query.\n   */\n  @property()\n  get value(): string {\n    return this[VALUE];\n  }\n\n  set value(value: string) {\n    this.lastUserSetValue = value;\n    this.select(value);\n  }\n\n  [VALUE] = '';\n\n  get options() {\n    // NOTE: this does a DOM query.\n    return (this.menu?.items ?? []) as SelectOption[];\n  }\n\n  /**\n   * The index of the currently selected option.\n   *\n   * Note: For SSR, set `[selected]` on the requested option and `displayText`\n   * rather than setting `selectedIndex` setting `selectedIndex` will incur a\n   * DOM query.\n   */\n  @property({type: Number, attribute: 'selected-index'})\n  get selectedIndex(): number {\n    // tslint:disable-next-line:enforce-name-casing\n    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];\n    return index ?? -1;\n  }\n\n  set selectedIndex(index: number) {\n    this.lastUserSetSelectedIndex = index;\n    this.selectIndex(index);\n  }\n\n  /**\n   * Returns an array of selected options.\n   *\n   * NOTE: md-select only suppoprts single selection.\n   */\n  get selectedOptions() {\n    return (this.getSelectedOptions() ?? []).map(([option]) => option);\n  }\n\n  protected abstract readonly fieldTag: StaticValue;\n\n  /**\n   * Used for initializing select when the user sets the `value` directly.\n   */\n  private lastUserSetValue: string|null = null;\n\n  /**\n   * Used for initializing select when the user sets the `selectedIndex`\n   * directly.\n   */\n  private lastUserSetSelectedIndex: number|null = null;\n\n  /**\n   * Used for `input` and `change` event change detection.\n   */\n  private lastSelectedOption: SelectOption|null = null;\n\n  // tslint:disable-next-line:enforce-name-casing\n  private lastSelectedOptionRecords: SelectOptionRecord[] = [];\n\n  protected override render() {\n    return html`\n      <span\n          class=\"select ${classMap(this.getRenderClasses())}\"\n          @focusout=${this.handleFocusout}>\n        ${this.renderField()}\n        ${this.renderMenu()}\n      </span>\n    `;\n  }\n\n  private getRenderClasses() {\n    return {\n      'disabled': this.disabled,\n      'error': this.error,\n      'open': this.open,\n    };\n  }\n\n  private renderField() {\n    // TODO(b/290078041): add aria-label/describedby\n    return staticHtml`\n      <${this.fieldTag}\n          aria-haspopup=\"listbox\"\n          role=\"combobox\"\n          part=\"field\"\n          tabindex=${this.disabled ? '-1' : '0'}\n          aria-expanded=${this.open ? 'true' : 'false'}\n          class=\"field\"\n          label=${this.label}\n          .focused=${this.focused || this.open}\n          .populated=${!!this.displayText}\n          .disabled=${this.disabled}\n          .required=${this.required}\n          .error=${this.error}\n          ?has-start=${this.hasLeadingIcon}\n          has-end\n          supporting-text=${this.supportingText}\n          error-text=${this.errorText}\n          @keydown =${this.handleKeydown}\n          @click=${this.handleClick}\n          @focus=${this.handleFocus}\n          @blur=${this.handleBlur}>\n        ${this.renderFieldContent()}\n      </${this.fieldTag}>`;\n  }\n\n  private renderFieldContent() {\n    return [\n      this.renderLeadingIcon(),\n      this.renderLabel(),\n      this.renderTrailingIcon(),\n    ];\n  }\n\n  private renderLeadingIcon() {\n    return html`\n      <span class=\"icon leading\" slot=\"start\">\n         <slot name=\"leadingicon\" @slotchange=${this.handleIconChange}></slot>\n      </span>\n     `;\n  }\n\n  private renderTrailingIcon() {\n    return html`\n      <span class=\"icon trailing\" slot=\"end\">\n        <slot name=\"trailingicon\" @slotchange=${this.handleIconChange}>\n          <svg height=\"5\" viewBox=\"7 10 10 5\" focusable=\"false\">\n            <polygon class=\"down\" stroke=\"none\" fill-rule=\"evenodd\" points=\"7 10 12 15 17 10\"></polygon>\n            <polygon class=\"up\" stroke=\"none\" fill-rule=\"evenodd\" points=\"7 15 12 10 17 15\"></polygon>\n          </svg>\n        </slot>\n      </span>\n     `;\n  }\n\n  private renderLabel() {\n    // need to render &nbsp; so that line-height can apply and give it a\n    // non-zero height\n    return html`<div id=\"label\">${this.displayText || html`&nbsp;`}</div>`;\n  }\n\n  private renderMenu() {\n    return html`\n      <md-menu\n          id=\"listbox\"\n          default-focus=\"NONE\"\n          listTabIndex=\"-1\"\n          type=\"listbox\"\n          stay-open-on-focusout\n          part=\"menu\"\n          exportparts=\"focus-ring: menu-focus-ring\"\n          .anchor=${this.field}\n          .open=${this.open}\n          .quick=${this.quick}\n          .fixed=${this.menuFixed}\n          .typeaheadDelay=${this.typeaheadDelay}\n          @opening=${this.handleOpening}\n          @closing=${this.handleClosing}\n          @close-menu=${this.handleCloseMenu}\n          @request-selection=${this.handleRequestSelection}\n          @request-deselection=${this.handleRequestDeselection}>\n        ${this.renderMenuContent()}\n      </md-menu>`;\n  }\n\n  private renderMenuContent() {\n    return html`<slot></slot>`;\n  }\n\n  /**\n   * Handles opening the select on keydown and typahead selection when the menu\n   * is closed.\n   */\n  private handleKeydown(event: KeyboardEvent) {\n    if (this.open || this.disabled || !this.menu) {\n      return;\n    }\n\n    const typeaheadController = this.menu.typeaheadController;\n    const isOpenKey = event.code === 'Space' || event.code === 'ArrowDown' ||\n        event.code === 'Enter';\n\n    // Do not open if currently typing ahead because the user may be typing the\n    // spacebar to match a word with a space\n    if (!typeaheadController.isTypingAhead && isOpenKey) {\n      event.preventDefault();\n      this.open = true;\n      return;\n    }\n\n    const isPrintableKey = event.key.length === 1;\n\n    // Handles typing ahead when the menu is closed by delegating the event to\n    // the underlying menu's typeaheadController\n    if (isPrintableKey) {\n      typeaheadController.onKeydown(event);\n      event.preventDefault();\n\n      const {lastActiveRecord} = typeaheadController;\n\n      if (!lastActiveRecord) {\n        return;\n      }\n\n      const hasChanged = this.selectItem(\n          lastActiveRecord[TYPEAHEAD_RECORD.ITEM] as SelectOption);\n\n      if (hasChanged) {\n        this.dispatchInteractionEvents();\n      }\n    }\n  }\n\n  private handleClick() {\n    this.open = true;\n  }\n\n  private handleFocus() {\n    this.focused = true;\n  }\n\n  private handleBlur() {\n    this.focused = false;\n  }\n\n  /**\n   * Handles closing the menu when the focus leaves the select's subtree.\n   */\n  private handleFocusout(event: FocusEvent) {\n    // Don't close the menu if we are switching focus between menu,\n    // select-option, and field\n    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {\n      return;\n    }\n\n    this.open = false;\n  }\n\n  /**\n   * Gets a list of all selected select options as a list item record array.\n   *\n   * @return An array of selected list option records.\n   */\n  private getSelectedOptions() {\n    if (!this.menu) {\n      this.lastSelectedOptionRecords = [];\n      return null;\n    }\n\n    const items = this.menu.items as SelectOption[];\n    this.lastSelectedOptionRecords = getSelectedItems(items);\n    return this.lastSelectedOptionRecords;\n  }\n\n  override async getUpdateComplete() {\n    await this.menu?.updateComplete;\n    return super.getUpdateComplete();\n  }\n\n  /**\n   * Gets the selected options from the DOM, and updates the value and display\n   * text to the first selected option's value and headline respectively.\n   *\n   * @return Whether or not the selected option has changed since last update.\n   */\n  private updateValueAndDisplayText() {\n    const selectedOptions = this.getSelectedOptions() ?? [];\n    // Used to determine whether or not we need to fire an input / change event\n    // which fire whenever the option element changes (value or selectedIndex)\n    // on user interaction.\n    let hasSelectedOptionChanged = false;\n\n    if (selectedOptions.length) {\n      const [firstSelectedOption] = selectedOptions[0];\n      hasSelectedOptionChanged =\n          this.lastSelectedOption !== firstSelectedOption;\n      this.lastSelectedOption = firstSelectedOption;\n      this[VALUE] = firstSelectedOption.value;\n      this.displayText = firstSelectedOption.headline;\n\n    } else {\n      hasSelectedOptionChanged = this.lastSelectedOption !== null;\n      this.lastSelectedOption = null;\n      this[VALUE] = '';\n      this.displayText = '';\n    }\n\n    return hasSelectedOptionChanged;\n  }\n\n  protected override update(changed: PropertyValues<this>) {\n    // In SSR the options will be ready to query, so try to figure out what\n    // the value and display text should be.\n    if (!this.hasUpdated) {\n      this.initUserSelection();\n    }\n\n    super.update(changed);\n  }\n\n  protected override async firstUpdated(changed: PropertyValues<this>) {\n    await this.menu?.updateComplete;\n    // If this has been handled on update already due to SSR, try again.\n    if (!this.lastSelectedOptionRecords.length) {\n      this.initUserSelection();\n    }\n\n    super.firstUpdated(changed);\n  }\n\n  /**\n   * Focuses and activates the last selected item upon opening, and resets other\n   * active items.\n   */\n  private async handleOpening() {\n    const items = this.menu!.items;\n    const activeItem = List.getActiveItem(items)?.item;\n    const [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];\n\n    // This is true if the user keys through the list but clicks out of the menu\n    // thus no close-menu event is fired by an item and we can't clean up in\n    // handleCloseMenu.\n    if (activeItem && activeItem !== selectedItem) {\n      activeItem.active = false;\n    }\n\n    if (selectedItem) {\n      selectedItem.active = true;\n      selectedItem.focus();\n    }\n  }\n\n  private handleClosing() {\n    this.open = false;\n  }\n\n  /**\n   * Determines the reason for closing, and updates the UI accordingly.\n   */\n  private handleCloseMenu(event: CloseMenuEvent) {\n    const reason = event.detail.reason;\n    const item = event.detail.itemPath[0] as SelectOption;\n    this.open = false;\n    let hasChanged = false;\n\n    if (reason.kind === 'CLICK_SELECTION') {\n      hasChanged = this.selectItem(item);\n    } else if (reason.kind === 'KEYDOWN' && isSelectableKey(reason.key)) {\n      hasChanged = this.selectItem(item);\n    } else {\n      // This can happen on ESC being pressed\n      item.active = false;\n      item.blur();\n    }\n\n    // Dispatch interaction events since selection has been made via keyboard\n    // or mouse.\n    if (hasChanged) {\n      this.dispatchInteractionEvents();\n    }\n  }\n\n  /**\n   * Selects a given option, deselects other options, and updates the UI.\n   *\n   * @return Whether the last selected option has changed.\n   */\n  private selectItem(item: SelectOption) {\n    this.lastSelectedOptionRecords.forEach(([option]) => {\n      if (item !== option) {\n        option.selected = false;\n      }\n    });\n    item.selected = true;\n\n    return this.updateValueAndDisplayText();\n  }\n\n  /**\n   * Handles updating selection when an option element requests selection via\n   * property / attribute change.\n   */\n  private handleRequestSelection(\n      event: ReturnType<typeof createRequestSelectionEvent>) {\n    const requestingOptionEl = event.target as SelectOption & HTMLElement;\n\n    // No-op if this item is already selected.\n    if (this.lastSelectedOptionRecords.some(\n            ([option]) => option === requestingOptionEl)) {\n      return;\n    }\n\n    this.selectItem(requestingOptionEl);\n  }\n\n  /**\n   * Handles updating selection when an option element requests deselection via\n   * property / attribute change.\n   */\n  private handleRequestDeselection(\n      event: ReturnType<typeof createRequestDeselectionEvent>) {\n    const requestingOptionEl = event.target as SelectOption & HTMLElement;\n\n    // No-op if this item is not even in the list of tracked selected items.\n    if (!this.lastSelectedOptionRecords.some(\n            ([option]) => option === requestingOptionEl)) {\n      return;\n    }\n\n    this.updateValueAndDisplayText();\n  }\n\n  /**\n   * Selects an option given the value of the option, and updates MdSelect's\n   * value.\n   */\n  select(value: string) {\n    const optionToSelect = this.options.find(option => option.value === value);\n    if (optionToSelect) {\n      this.selectItem(optionToSelect);\n    }\n  }\n\n  /**\n   * Selects an option given the index of the option, and updates MdSelect's\n   * value.\n   */\n  selectIndex(index: number) {\n    const optionToSelect = this.options[index];\n    if (optionToSelect) {\n      this.selectItem(optionToSelect);\n    }\n  }\n\n  /**\n   * Attempts to initialize the selected option from user-settable values like\n   * SSR, setting `value`, or `selectedIndex` at startup.\n   */\n  private initUserSelection() {\n    // User has set `.value` directly, but internals have not yet booted up.\n    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {\n      this.select(this.lastUserSetValue);\n\n      // User has set `.selectedIndex` directly, but internals have not yet\n      // booted up.\n    } else if (\n        this.lastUserSetSelectedIndex !== null &&\n        !this.lastSelectedOptionRecords.length) {\n      this.selectIndex(this.lastUserSetSelectedIndex);\n\n      // Regular boot up!\n    } else {\n      this.updateValueAndDisplayText();\n    }\n  }\n\n  private handleIconChange() {\n    this.hasLeadingIcon = this.leadingIcons.length > 0;\n  }\n\n  /**\n   * Dispatches the `input` and `change` events.\n   */\n  private dispatchInteractionEvents() {\n    this.dispatchEvent(new Event('input', {bubbles: true, composed: true}));\n    this.dispatchEvent(new Event('change', {bubbles: true}));\n  }\n}\n"],
  "mappings": "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",
  "names": ["styles", "_a", "styles", "MdList", "styles", "_a", "styles", "MdMenu", "styles", "_a", "html"]
}
