{
  "version": 3,
  "sources": ["../../@material/web/select/internal/shared-styles.css.ts", "../../@material/web/list/internal/list-navigation-helpers.ts", "../../@material/web/list/internal/list-controller.ts", "../../@material/web/menu/internal/controllers/surfacePositionController.ts", "../../@material/web/menu/internal/controllers/typeaheadController.ts", "../../@material/web/menu/internal/menu.ts", "../../@material/web/menu/internal/menu-styles.css.ts", "../../@material/web/menu/menu.ts", "../../@material/web/select/internal/shared.ts", "../../@material/web/select/internal/select.ts"],
  "sourcesContent": ["/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{color:unset;min-width:210px;display:flex}.field{cursor:default;outline:none}.select{position:relative;flex-direction:column}.icon.trailing svg,.icon ::slotted(*){fill:currentColor}.icon ::slotted(*){width:inherit;height:inherit;font-size:inherit}.icon slot{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.icon.trailing :is(.up,.down){opacity:0;transition:opacity 75ms linear 75ms}.select:not(.open) .down,.select.open .up{opacity:1}.field,.select,md-menu{min-width:inherit;width:inherit;max-width:inherit;display:flex}md-menu ::slotted(:not[disabled]){cursor:pointer}.field,.select{width:100%}:host{display:inline-flex}:host([disabled]){pointer-events:none}/*# sourceMappingURL=shared-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport interface ListItem extends HTMLElement {\n  disabled: boolean;\n}\n\n/**\n * A record that describes a list item in a list with metadata such a reference\n * to the item and its index in the list.\n */\nexport interface ItemRecord<Item extends ListItem> {\n  item: Item;\n  index: number;\n}\n\n/**\n * Activates the first non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     first item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n */\nexport function activateFirstItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  // NOTE: These selector functions are static and not on the instance such\n  // that multiple operations can be chained and we do not have to re-query\n  // the DOM\n  const firstItem = getFirstActivatableItem(items, isActivatable);\n  if (firstItem) {\n    firstItem.tabIndex = 0;\n    firstItem.focus();\n  }\n  return firstItem;\n}\n\n/**\n * Activates the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     last item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @nocollapse\n */\nexport function activateLastItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  const lastItem = getLastActivatableItem(items, isActivatable);\n  if (lastItem) {\n    lastItem.tabIndex = 0;\n    lastItem.focus();\n  }\n  return lastItem;\n}\n\n/**\n * Deactivates the currently active item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to deactivate the\n *     active item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the deleselcted activated item including the item and\n *     the index of the item or `null` if none are deactivated.\n * @nocollapse\n */\nexport function deactivateActiveItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  const activeItem = getActiveItem(items, isActivatable);\n  if (activeItem) {\n    activeItem.item.tabIndex = -1;\n  }\n  return activeItem;\n}\n\n/**\n * Retrieves the first activated item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the first activated item including the item and the\n *     index of the item or `null` if none are activated.\n * @nocollapse\n */\nexport function getActiveItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (item.tabIndex === 0 && isActivatable(item)) {\n      return {\n        item,\n        index: i,\n      } as ItemRecord<Item>;\n    }\n  }\n  return null;\n}\n\n/**\n * Retrieves the first non-disabled item of a given array of items. This\n * the first item that is not disabled.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The first activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getFirstActivatableItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  for (const item of items) {\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Retrieves the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The last activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getLastActivatableItem<Item extends ListItem>(\n    items: Item[], isActivatable = isItemNotDisabled<Item>) {\n  for (let i = items.length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Retrieves the next non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The next activatable item or `null` if none are activatable.\n */\nexport function getNextItem<Item extends ListItem>(\n    items: Item[], index: number, isActivatable = isItemNotDisabled<Item>) {\n  for (let i = 1; i < items.length; i++) {\n    const nextIndex = (i + index) % items.length;\n    const item = items[nextIndex];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return items[index] ? items[index] : null;\n}\n\n/**\n * Retrieves the previous non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The previous activatable item or `null` if none are activatable.\n */\nexport function getPrevItem<Item extends ListItem>(\n    items: Item[], index: number, isActivatable = isItemNotDisabled<Item>) {\n  for (let i = 1; i < items.length; i++) {\n    const prevIndex = (index - i + items.length) % items.length;\n    const item = items[prevIndex];\n\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return items[index] ? items[index] : null;\n}\n\n/**\n * Activates the next item and focuses it. If nothing is currently activated,\n * activates the first item.\n */\nexport function activateNextItem<Item extends ListItem>(\n    items: Item[], activeItemRecord: null|ItemRecord<Item>,\n    isActivatable = isItemNotDisabled<Item>): Item|null {\n  if (activeItemRecord) {\n    const next = getNextItem(items, activeItemRecord.index, isActivatable);\n\n    if (next) {\n      next.tabIndex = 0;\n      next.focus();\n    }\n\n    return next;\n  } else {\n    return activateFirstItem(items, isActivatable);\n  }\n}\n\n/**\n * Activates the previous item and focuses it. If nothing is currently\n * activated, activates the last item.\n */\nexport function activatePreviousItem<Item extends ListItem>(\n    items: Item[], activeItemRecord: null|ItemRecord<Item>,\n    isActivatable = isItemNotDisabled<Item>): Item|null {\n  if (activeItemRecord) {\n    const prev = getPrevItem(items, activeItemRecord.index, isActivatable);\n    if (prev) {\n      prev.tabIndex = 0;\n      prev.focus();\n    }\n    return prev;\n  } else {\n    return activateLastItem(items, isActivatable);\n  }\n}\n\n/**\n * Creates an event that requests the parent md-list to deactivate all other\n * items.\n */\nexport function createDeactivateItemsEvent() {\n  return new Event('deactivate-items', {bubbles: true, composed: true});\n}\n\n/**\n * The type of the event that requests the parent md-list to deactivate all\n * other items.\n */\nexport type DeactivateItemsEvent =\n    ReturnType<typeof createDeactivateItemsEvent>;\n\n/**\n * Creates an event that requests the menu to set `tabindex=0` on the item and\n * focus it. We use this pattern because List keeps track of what element is\n * active in the List by maintaining tabindex. We do not want list items\n * to set tabindex on themselves or focus themselves so that we can organize all\n * that logic in the parent List and Menus, and list item stays as dumb as\n * possible.\n */\nexport function createRequestActivationEvent() {\n  return new Event('request-activation', {bubbles: true, composed: true});\n}\n\n/**\n * The type of the event that requests the list activates and focuses the item.\n */\nexport type RequestActivationEvent =\n    ReturnType<typeof createRequestActivationEvent>;\n\n/**\n * The default `isActivatable` function, which checks if an item is not\n * disabled.\n *\n * @param item The item to check.\n * @return true if `item.disabled` is `false.\n */\nfunction isItemNotDisabled<Item extends ListItem>(item: Item) {\n  return !item.disabled;\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {activateFirstItem, activateLastItem, activateNextItem, activatePreviousItem, getActiveItem, getFirstActivatableItem, ListItem} from './list-navigation-helpers.js';\n\n// TODO: move this file to List and make List use this\n\n/**\n * Default keys that trigger navigation.\n */\n// tslint:disable:enforce-name-casing Following Enum style\nexport const NavigableKeys = {\n  ArrowDown: 'ArrowDown',\n  ArrowLeft: 'ArrowLeft',\n  ArrowUp: 'ArrowUp',\n  ArrowRight: 'ArrowRight',\n  Home: 'Home',\n  End: 'End',\n} as const;\n// tslint:enable:enforce-name-casing\n\n/**\n * Default set of navigable keys.\n */\nexport type NavigableKeys = typeof NavigableKeys[keyof typeof NavigableKeys];\n\n/**\n * The configuration object to customize the behavior of the List Controller\n */\nexport interface ListControllerConfig<Item extends ListItem> {\n  /**\n   * A function that determines whether or not the given element is an Item\n   */\n  isItem: (item: HTMLElement) => item is Item;\n  /**\n   * A function that returns an array of elements to consider as items. For\n   * example, all the slotted elements.\n   */\n  getPossibleItems: () => HTMLElement[];\n  /**\n   * A function that returns whether or not the list is in an RTL context.\n   */\n  isRtl: () => boolean;\n  /**\n   * Deactivates an item such as setting the tabindex to -1 and or sets selected\n   * to false.\n   */\n  deactivateItem: (item: Item) => void;\n  /**\n   * Activates an item such as setting the tabindex to 1 and or sets selected to\n   * true (but does not focus).\n   */\n  activateItem: (item: Item) => void;\n  /**\n   * Whether or not the key should be handled by the list for navigation.\n   */\n  isNavigableKey: (key: string) => boolean;\n  /**\n   * Whether or not the item can be activated. Defaults to items that are not\n   * disabled.\n   */\n  isActivatable?: (item: Item) => boolean;\n}\n\n/**\n * A controller that handles list keyboard navigation and item management.\n */\nexport class ListController<Item extends ListItem> {\n  isItem: (item: HTMLElement) => item is Item;\n  private readonly getPossibleItems: () => HTMLElement[];\n  private readonly isRtl: () => boolean;\n  private readonly deactivateItem: (item: Item) => void;\n  private readonly activateItem: (item: Item) => void;\n  private readonly isNavigableKey: (key: string) => boolean;\n  private readonly isActivatable?: (item: Item) => boolean;\n\n  constructor(config: ListControllerConfig<Item>) {\n    const {\n      isItem,\n      getPossibleItems,\n      isRtl,\n      deactivateItem,\n      activateItem,\n      isNavigableKey,\n      isActivatable,\n    } = config;\n    this.isItem = isItem;\n    this.getPossibleItems = getPossibleItems;\n    this.isRtl = isRtl;\n    this.deactivateItem = deactivateItem;\n    this.activateItem = activateItem;\n    this.isNavigableKey = isNavigableKey;\n    this.isActivatable = isActivatable;\n  }\n\n  /**\n   * The items being managed by the list. Additionally, attempts to see if the\n   * object has a sub-item in the `.item` property.\n   */\n  get items(): Item[] {\n    const maybeItems = this.getPossibleItems();\n    const items: Item[] = [];\n\n    for (const itemOrParent of maybeItems) {\n      const isItem = this.isItem(itemOrParent);\n      // if the item is a list item, add it to the list of items\n      if (isItem) {\n        items.push(itemOrParent);\n        continue;\n      }\n\n      // If the item exposes an `item` property check if it is a list item.\n      const subItem = (itemOrParent as HTMLElement & {item?: Item}).item;\n      if (subItem && this.isItem(subItem)) {\n        items.push(subItem);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * Handles keyboard navigation. Should be bound to the node that will act as\n   * the List.\n   */\n  handleKeydown = (event: KeyboardEvent) => {\n    const key = event.key;\n    if (event.defaultPrevented || !this.isNavigableKey(key)) {\n      return;\n    }\n    // do not use this.items directly in upcoming calculations so we don't\n    // re-query the DOM unnecessarily\n    const items = this.items;\n\n    if (!items.length) {\n      return;\n    }\n\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n\n    event.preventDefault();\n\n    const isRtl = this.isRtl();\n    const inlinePrevious =\n        isRtl ? NavigableKeys.ArrowRight : NavigableKeys.ArrowLeft;\n    const inlineNext =\n        isRtl ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;\n\n    switch (key) {\n      // Activate the next item\n      case NavigableKeys.ArrowDown:\n      case inlineNext:\n        activateNextItem(items, activeItemRecord, this.isActivatable);\n        break;\n\n      // Activate the previous item\n      case NavigableKeys.ArrowUp:\n      case inlinePrevious:\n        activatePreviousItem(items, activeItemRecord, this.isActivatable);\n        break;\n\n      // Activate the first item\n      case NavigableKeys.Home:\n        activateFirstItem(items, this.isActivatable);\n        break;\n\n      // Activate the last item\n      case NavigableKeys.End:\n        activateLastItem(items, this.isActivatable);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Activates the next item in the list. If at the end of the list, the first\n   * item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activateNextItem(): Item|null {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activateNextItem(items, activeItemRecord, this.isActivatable);\n  }\n\n  /**\n   * Activates the previous item in the list. If at the start of the list, the\n   * last item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activatePreviousItem(): Item|null {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activatePreviousItem(items, activeItemRecord, this.isActivatable);\n  }\n\n  /**\n   * Listener to be bound to the `deactivate-items` item event.\n   */\n  onDeactivateItems = () => {\n    const items = this.items;\n\n    for (const item of items) {\n      this.deactivateItem(item);\n    }\n  };\n\n  /**\n   * Listener to be bound to the `request-activation` item event..\n   */\n  onRequestActivation = (event: Event) => {\n    this.onDeactivateItems();\n    const target = event.target as Item;\n    this.activateItem(target);\n    target.focus();\n  };\n\n  /**\n   * Listener to be bound to the `slotchange` event for the slot that renders\n   * the items.\n   */\n  onSlotchange = () => {\n    const items = this.items;\n    // Whether we have encountered an item that has been activated\n    let encounteredActivated = false;\n\n    for (const item of items) {\n      const isActivated = !item.disabled && item.tabIndex > -1;\n\n      if (isActivated && !encounteredActivated) {\n        encounteredActivated = true;\n        item.tabIndex = 0;\n        continue;\n      }\n\n      // Deactivate the rest including disabled\n      item.tabIndex = -1;\n    }\n\n    if (encounteredActivated) {\n      return;\n    }\n\n    const firstActivatableItem =\n        getFirstActivatableItem(items, this.isActivatable);\n\n    if (!firstActivatableItem) {\n      return;\n    }\n\n    firstActivatableItem.tabIndex = 0;\n  };\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveController, ReactiveControllerHost} from 'lit';\nimport {StyleInfo} from 'lit/directives/style-map.js';\n\n/**\n * An enum of supported Menu corners\n */\n// tslint:disable-next-line:enforce-name-casing We are mimicking enum style\nexport const Corner = {\n  END_START: 'end-start',\n  END_END: 'end-end',\n  START_START: 'start-start',\n  START_END: 'start-end',\n} as const;\n\n/**\n * A corner of a box in the standard logical property style of <block>_<inline>\n */\nexport type Corner = typeof Corner[keyof typeof Corner];\n\n/**\n * An interface that provides a method to customize the rect from which to\n * calculate the anchor positioning. Useful for when you want a surface to\n * anchor to an element in your shadow DOM rather than the host element.\n */\nexport interface SurfacePositionTarget extends HTMLElement {\n  getSurfacePositionClientRect?: () => DOMRect;\n}\n\n/**\n * The configurable options for the surface position controller.\n */\nexport interface SurfacePositionControllerProperties {\n  /**\n   * The corner of the anchor to align the surface's position.\n   */\n  anchorCorner: Corner;\n  /**\n   * The corner of the surface to align to the given anchor corner.\n   */\n  surfaceCorner: Corner;\n  /**\n   * The HTMLElement reference of the surface to be positioned.\n   */\n  surfaceEl: SurfacePositionTarget|null;\n  /**\n   * The HTMLElement reference of the anchor to align to.\n   */\n  anchorEl: SurfacePositionTarget|null;\n  /**\n   * Whether the positioning algorithim should calculate relative to the parent\n   * of the anchor element (absolute) or relative to the window (fixed).\n   *\n   * Examples for `position = 'fixed'`:\n   *\n   * - If there is no `position:relative` in the given parent tree and the\n   *   surface is `position:absolute`\n   * - If the surface is `position:fixed`\n   * - If the surface is in the \"top layer\"\n   * - The anchor and the surface do not share a common `position:relative`\n   *   ancestor\n   */\n  positioning: 'absolute'|'fixed';\n  /**\n   * Whether or not the surface should be \"open\" and visible\n   */\n  isOpen: boolean;\n  /**\n   * The number of pixels in which to offset from the inline axis relative to\n   * logical property.\n   *\n   * Positive is right in LTR and left in RTL.\n   */\n  xOffset: number;\n  /**\n   * The number of pixes in which to offset the block axis.\n   *\n   * Positive is down and negative is up.\n   */\n  yOffset: number;\n  /**\n   * The strategy to follow when repositioning the menu to stay inside the\n   * viewport. \"move\" will simply move the surface to stay in the viewport.\n   * \"resize\" will attempt to resize the surface.\n   *\n   * Both strategies will still attempt to flip the anchor and surface corners.\n   */\n  repositionStrategy: 'move'|'resize';\n  /**\n   * A function to call after the surface has been positioned.\n   */\n  onOpen: () => void;\n  /**\n   * A function to call before the surface should be closed. (A good time to\n   * perform animations while the surface is still visible)\n   */\n  beforeClose: () => Promise<void>;\n  /**\n   * A function to call after the surface has been closed.\n   */\n  onClose: () => void;\n}\n\n/**\n * Given a surface, an anchor, corners, and some options, this surface will\n * calculate the position of a surface to align the two given corners and keep\n * the surface inside the window viewport. It also provides a StyleInfo map that\n * can be applied to the surface to handle visiblility and position.\n */\nexport class SurfacePositionController implements ReactiveController {\n  // The current styles to apply to the surface.\n  private surfaceStylesInternal: StyleInfo = {\n    'display': 'none',\n  };\n  // Previous values stored for change detection. Open change detection is\n  // calculated separately so initialize it here.\n  private lastValues: SurfacePositionControllerProperties = {isOpen: false} as\n      SurfacePositionControllerProperties;\n\n  /**\n   * @param host The host to connect the controller to.\n   * @param getProperties A function that returns the properties for the\n   * controller.\n   */\n  constructor(\n      private readonly host: ReactiveControllerHost,\n      private readonly getProperties: () => SurfacePositionControllerProperties,\n  ) {\n    this.host.addController(this);\n  }\n\n  /**\n   * The StyleInfo map to apply to the surface via Lit's stylemap\n   */\n  get surfaceStyles() {\n    return this.surfaceStylesInternal;\n  }\n\n  /**\n   * Calculates the surface's new position required so that the surface's\n   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the\n   * surface inside the window viewport. This positioning also respects RTL by\n   * checking `getComputedStyle()` on the surface element.\n   */\n  async position() {\n    const {\n      surfaceEl,\n      anchorEl,\n      anchorCorner: anchorCornerRaw,\n      surfaceCorner: surfaceCornerRaw,\n      positioning,\n      xOffset,\n      yOffset,\n      repositionStrategy,\n    } = this.getProperties();\n    const anchorCorner = anchorCornerRaw.toLowerCase().trim();\n    const surfaceCorner = surfaceCornerRaw.toLowerCase().trim();\n\n    if (!surfaceEl || !anchorEl) {\n      return;\n    }\n\n    // Store these before we potentially resize the window with the next set of\n    // lines\n    const windowInnerWidth = window.innerWidth;\n    const windowInnerHeight = window.innerHeight;\n\n    // Paint the surface transparently so that we can get the position and the\n    // rect info of the surface.\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '0',\n    };\n\n    // Wait for it to be visible.\n    this.host.requestUpdate();\n    await this.host.updateComplete;\n\n    const surfaceRect = surfaceEl.getSurfacePositionClientRect ?\n        surfaceEl.getSurfacePositionClientRect() :\n        surfaceEl.getBoundingClientRect();\n    const anchorRect = anchorEl.getSurfacePositionClientRect ?\n        anchorEl.getSurfacePositionClientRect() :\n        anchorEl.getBoundingClientRect();\n    const [surfaceBlock, surfaceInline] =\n        surfaceCorner.split('-') as Array<'start'|'end'>;\n    const [anchorBlock, anchorInline] =\n        anchorCorner.split('-') as Array<'start'|'end'>;\n\n    // LTR depends on the direction of the SURFACE not the anchor.\n    const isLTR =\n        getComputedStyle(surfaceEl as HTMLElement).direction === 'ltr';\n\n    /*\n     * A diagram that helps describe some of the variables used in the following\n     * calculations.\n     *\n     * ┌───── inline/blockTopLayerOffset\n     * │       │\n     * │     ┌─▼───┐                  Window\n     * │    ┌┼─────┴────────────────────────┐\n     * │    ││                              │\n     * └──► ││  ┌──inline/blockAnchorOffset │\n     *      ││  │     │                     │\n     *      └┤  │  ┌──▼───┐                 │\n     *       │  │ ┌┼──────┤                 │\n     *       │  └─►│Anchor│                 │\n     *       │    └┴──────┘                 │\n     *       │                              │\n     *       │     ┌────────────────────────┼────┐\n     *       │     │ Surface                │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       │     │                        │    │\n     *       └─────┼────────────────────────┘    ├┐\n     *             │ inline/blockOOBCorrection   ││\n     *             │                         │   ││\n     *             │                         ├──►││\n     *             │                         │   ││\n     *             └────────────────────────┐▼───┼┘\n     *                                      └────┘\n     */\n\n    // Calculate the block positioning properties\n    let {blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty} =\n        this.calculateBlock({\n          surfaceRect,\n          anchorRect,\n          anchorBlock,\n          surfaceBlock,\n          yOffset,\n          positioning,\n          windowInnerHeight,\n        });\n\n    // If the surface should be out of bounds in the block direction, flip the\n    // surface and anchor corner block values and recalculate\n    if (blockOutOfBoundsCorrection) {\n      const flippedSurfaceBlock = surfaceBlock === 'start' ? 'end' : 'start';\n      const flippedAnchorBlock = anchorBlock === 'start' ? 'end' : 'start';\n\n      const flippedBlock = this.calculateBlock({\n        surfaceRect,\n        anchorRect,\n        anchorBlock: flippedAnchorBlock,\n        surfaceBlock: flippedSurfaceBlock,\n        yOffset,\n        positioning,\n        windowInnerHeight,\n      });\n\n      // In the case that the flipped verion would require less out of bounds\n      // correcting, use the flipped corner block values\n      if (blockOutOfBoundsCorrection >\n          flippedBlock.blockOutOfBoundsCorrection) {\n        blockInset = flippedBlock.blockInset;\n        blockOutOfBoundsCorrection = flippedBlock.blockOutOfBoundsCorrection;\n        surfaceBlockProperty = flippedBlock.surfaceBlockProperty;\n      }\n    }\n\n    // Calculate the inline positioning properties\n    let {inlineInset, inlineOutOfBoundsCorrection, surfaceInlineProperty} =\n        this.calculateInline({\n          surfaceRect,\n          anchorRect,\n          anchorInline,\n          surfaceInline,\n          xOffset,\n          positioning,\n          isLTR,\n          windowInnerWidth,\n        });\n\n    // If the surface should be out of bounds in the inline direction, flip the\n    // surface and anchor corner inline values and recalculate\n    if (inlineOutOfBoundsCorrection) {\n      const flippedSurfaceInline = surfaceInline === 'start' ? 'end' : 'start';\n      const flippedAnchorInline = anchorInline === 'start' ? 'end' : 'start';\n\n      const flippedInline = this.calculateInline({\n        surfaceRect,\n        anchorRect,\n        anchorInline: flippedAnchorInline,\n        surfaceInline: flippedSurfaceInline,\n        xOffset,\n        positioning,\n        isLTR,\n        windowInnerWidth,\n      });\n\n      // In the case that the flipped verion would require less out of bounds\n      // correcting, use the flipped corner inline values\n      if (Math.abs(inlineOutOfBoundsCorrection) >\n          Math.abs(flippedInline.inlineOutOfBoundsCorrection)) {\n        inlineInset = flippedInline.inlineInset;\n        inlineOutOfBoundsCorrection = flippedInline.inlineOutOfBoundsCorrection;\n        surfaceInlineProperty = flippedInline.surfaceInlineProperty;\n      }\n    }\n\n    // If we are simply repositioning the surface back inside the viewport,\n    // subtract the out of bounds correction values from the positioning.\n    if (repositionStrategy === 'move') {\n      blockInset = blockInset - blockOutOfBoundsCorrection;\n      inlineInset = inlineInset - inlineOutOfBoundsCorrection;\n    }\n\n    this.surfaceStylesInternal = {\n      'display': 'block',\n      'opacity': '1',\n      [surfaceBlockProperty]: `${blockInset}px`,\n      [surfaceInlineProperty]: `${inlineInset}px`,\n    };\n\n    // In the case that we are resizing the surface to stay inside the viewport\n    // we need to set height and width on the surface.\n    if (repositionStrategy === 'resize') {\n      // Add a height property to the styles if there is block height correction\n      if (blockOutOfBoundsCorrection) {\n        this.surfaceStylesInternal['height'] =\n            `${surfaceRect.height - blockOutOfBoundsCorrection}px`;\n      }\n\n      // Add a width property to the styles if there is block height correction\n      if (inlineOutOfBoundsCorrection) {\n        this.surfaceStylesInternal['width'] =\n            `${surfaceRect.width - inlineOutOfBoundsCorrection}px`;\n      }\n    }\n\n    this.host.requestUpdate();\n  }\n\n  /**\n   * Calculates the css property, the inset, and the out of bounds correction\n   * for the surface in the block direction.\n   */\n  private calculateBlock(config: {\n    surfaceRect: DOMRect,\n    anchorRect: DOMRect,\n    anchorBlock: 'start'|'end',\n    surfaceBlock: 'start'|'end',\n    yOffset: number,\n    positioning: 'absolute'|'fixed',\n    windowInnerHeight: number,\n  }) {\n    const {\n      surfaceRect,\n      anchorRect,\n      anchorBlock,\n      surfaceBlock,\n      yOffset,\n      positioning,\n      windowInnerHeight,\n    } = config;\n    // We use number booleans to multiply values rather than `if` / ternary\n    // statements because it _heavily_ cuts down on nesting and readability\n    const relativeToWindow = positioning === 'fixed' ? 1 : 0;\n    const isSurfaceBlockStart = surfaceBlock === 'start' ? 1 : 0;\n    const isSurfaceBlockEnd = surfaceBlock === 'end' ? 1 : 0;\n    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;\n\n    // Whether or not to apply the height of the anchor\n    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;\n    // The absolute block position of the anchor relative to window\n    const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top +\n        isSurfaceBlockEnd * (windowInnerHeight - anchorRect.bottom);\n    // If the surface's block would be out of bounds of the window, move it back\n    // in\n    const blockOutOfBoundsCorrection = Math.abs(Math.min(\n        0,\n        windowInnerHeight - blockTopLayerOffset - blockAnchorOffset -\n            surfaceRect.height));\n\n\n    // The block logical value of the surface\n    const blockInset =\n        relativeToWindow * blockTopLayerOffset + blockAnchorOffset;\n\n    const surfaceBlockProperty =\n        surfaceBlock === 'start' ? 'inset-block-start' : 'inset-block-end';\n\n    return {blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty};\n  }\n\n  /**\n   * Calculates the css property, the inset, and the out of bounds correction\n   * for the surface in the inline direction.\n   */\n  private calculateInline(config: {\n    isLTR: boolean,\n    surfaceInline: 'start'|'end',\n    anchorInline: 'start'|'end',\n    anchorRect: DOMRect,\n    surfaceRect: DOMRect,\n    xOffset: number,\n    positioning: 'absolute'|'fixed',\n    windowInnerWidth: number,\n  }) {\n    const {\n      isLTR: isLTRBool,\n      surfaceInline,\n      anchorInline,\n      anchorRect,\n      surfaceRect,\n      xOffset,\n      positioning,\n      windowInnerWidth,\n    } = config;\n    // We use number booleans to multiply values rather than `if` / ternary\n    // statements because it _heavily_ cuts down on nesting and readability\n    const relativeToWindow = positioning === 'fixed' ? 1 : 0;\n    const isLTR = isLTRBool ? 1 : 0;\n    const isRTL = isLTRBool ? 0 : 1;\n    const isSurfaceInlineStart = surfaceInline === 'start' ? 1 : 0;\n    const isSurfaceInlineEnd = surfaceInline === 'end' ? 1 : 0;\n    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;\n\n    // Whether or not to apply the width of the anchor\n    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;\n    // The inline position of the anchor relative to window in LTR\n    const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left +\n        isSurfaceInlineEnd * (windowInnerWidth - anchorRect.right);\n    // The inline position of the anchor relative to window in RTL\n    const inlineTopLayerOffsetRTL =\n        isSurfaceInlineStart * (windowInnerWidth - anchorRect.right) +\n        isSurfaceInlineEnd * anchorRect.left;\n    // The inline position of the anchor relative to window\n    const inlineTopLayerOffset =\n        isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;\n\n    // If the surface's inline would be out of bounds of the window, move it\n    // back in\n    const inlineOutOfBoundsCorrection = Math.abs(Math.min(\n        0,\n        windowInnerWidth - inlineTopLayerOffset - inlineAnchorOffset -\n            surfaceRect.width));\n\n\n    // The inline logical value of the surface\n    const inlineInset =\n        relativeToWindow * inlineTopLayerOffset + inlineAnchorOffset;\n\n    const surfaceInlineProperty =\n        surfaceInline === 'start' ? 'inset-inline-start' : 'inset-inline-end';\n\n    return {\n      inlineInset,\n      inlineOutOfBoundsCorrection,\n      surfaceInlineProperty,\n    };\n  }\n\n  hostUpdate() {\n    this.onUpdate();\n  }\n\n  hostUpdated() {\n    this.onUpdate();\n  }\n\n  /**\n   * Checks whether the properties passed into the controller have changed since\n   * the last positioning. If so, it will reposition if the surface is open or\n   * close it if the surface should close.\n   */\n  private async onUpdate() {\n    const props = this.getProperties();\n    let hasChanged = false;\n    for (const [key, value] of Object.entries(props)) {\n      // tslint:disable-next-line\n      hasChanged = hasChanged || (value !== (this.lastValues as any)[key]);\n      if (hasChanged) break;\n    }\n\n    const openChanged = this.lastValues.isOpen !== props.isOpen;\n    const hasAnchor = !!props.anchorEl;\n    const hasSurface = !!props.surfaceEl;\n\n    if (hasChanged && hasAnchor && hasSurface) {\n      // Only update isOpen, because if it's closed, we do not want to waste\n      // time on a useless reposition calculation. So save the other \"dirty\"\n      // values until next time it opens.\n      this.lastValues.isOpen = props.isOpen;\n\n      if (props.isOpen) {\n        // We are going to do a reposition, so save the prop values for future\n        // dirty checking.\n        this.lastValues = props;\n\n        await this.position();\n        props.onOpen();\n      } else if (openChanged) {\n        await props.beforeClose();\n        this.close();\n        props.onClose();\n      }\n    }\n  }\n\n  /**\n   * Hides the surface.\n   */\n  private close() {\n    this.surfaceStylesInternal = {\n      'display': 'none',\n    };\n    this.host.requestUpdate();\n  }\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {MenuItem} from './menuItemController.js';\n\n/**\n * The options that are passed to the typeahead controller.\n */\nexport interface TypeaheadControllerProperties {\n  /**\n   * A function that returns an array of menu items to be searched.\n   * @return An array of menu items to be searched by typing.\n   */\n  getItems: () => MenuItem[];\n  /**\n   * The maximum time between each keystroke to keep the current type buffer\n   * alive.\n   */\n  typeaheadBufferTime: number;\n  /**\n   * Whether or not the typeahead should listen for keystrokes or not.\n   */\n  active: boolean;\n}\n\n/**\n * Data structure tuple that helps with indexing.\n *\n * [index, item, normalized header text]\n */\ntype TypeaheadRecord = [number, MenuItem, string];\n/**\n * Indicies to access the TypeaheadRecord tuple type.\n */\nexport const TYPEAHEAD_RECORD = {\n  INDEX: 0,\n  ITEM: 1,\n  TEXT: 2,\n} as const;\n\n/**\n * This controller listens to `keydown` events and searches the header text of\n * an array of `MenuItem`s with the corresponding entered keys within the buffer\n * time and activates the item.\n *\n * @example\n * ```ts\n * const typeaheadController = new TypeaheadController(() => ({\n *   typeaheadBufferTime: 50,\n *   getItems: () => Array.from(document.querySelectorAll('md-menu-item'))\n * }));\n * html`\n *   <div\n *       @keydown=${typeaheadController.onKeydown}\n *       tabindex=\"0\"\n *       class=\"activeItemText\">\n *     <!-- focusable element that will receive keydown events -->\n *     Apple\n *   </div>\n *   <div>\n *     <md-menu-item active header=\"Apple\"></md-menu-item>\n *     <md-menu-item header=\"Apricot\"></md-menu-item>\n *     <md-menu-item header=\"Banana\"></md-menu-item>\n *     <md-menu-item header=\"Olive\"></md-menu-item>\n *     <md-menu-item header=\"Orange\"></md-menu-item>\n *   </div>\n * `;\n * ```\n */\nexport class TypeaheadController {\n  /**\n   * Array of tuples that helps with indexing.\n   */\n  private typeaheadRecords: TypeaheadRecord[] = [];\n  /**\n   * Currently-typed text since last buffer timeout\n   */\n  private typaheadBuffer = '';\n  /**\n   * The timeout id from the current buffer's setTimeout\n   */\n  private cancelTypeaheadTimeout = 0;\n  /**\n   * If we are currently \"typing\"\n   */\n  isTypingAhead = false;\n  /**\n   * The record of the last active item.\n   */\n  lastActiveRecord: TypeaheadRecord|null = null;\n\n  /**\n   * @param getProperties A function that returns the options of the typeahead\n   * controller:\n   *\n   * {\n   *   getItems: A function that returns an array of menu items to be searched.\n   *   typeaheadBufferTime: The maximum time between each keystroke to keep the\n   *       current type buffer alive.\n   * }\n   */\n  constructor(\n      private readonly getProperties: () => TypeaheadControllerProperties,\n  ) {}\n\n  private get items() {\n    return this.getProperties().getItems();\n  }\n\n  private get active() {\n    return this.getProperties().active;\n  }\n\n  /**\n   * Apply this listener to the element that will receive `keydown` events that\n   * should trigger this controller.\n   *\n   * @param event The native browser `KeyboardEvent` from the `keydown` event.\n   */\n  readonly onKeydown = (event: KeyboardEvent) => {\n    if (this.isTypingAhead) {\n      this.typeahead(event);\n    } else {\n      this.beginTypeahead(event);\n    }\n  };\n\n  /**\n   * Sets up typingahead\n   */\n  private beginTypeahead(event: KeyboardEvent) {\n    if (!this.active) {\n      return;\n    }\n\n    // We don't want to typeahead if the _beginning_ of the typeahead is a menu\n    // navigation, or a selection. We will handle \"Space\" only if it's in the\n    // middle of a typeahead\n    if (event.code === 'Space' || event.code === 'Enter' ||\n        event.code.startsWith('Arrow') || event.code === 'Escape') {\n      return;\n    }\n\n    this.isTypingAhead = true;\n    // Generates the record array data structure which is the index, the element\n    // and a normalized header.\n    this.typeaheadRecords = this.items.map(\n        (el, index) => [index, el, el.typeaheadText.trim().toLowerCase()]);\n    this.lastActiveRecord =\n        this.typeaheadRecords.find(\n            record => (record[TYPEAHEAD_RECORD.ITEM].tabIndex === 0)) ??\n        null;\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n    }\n    this.typeahead(event);\n  }\n\n  /**\n   * Performs the typeahead. Based on the normalized items and the current text\n   * buffer, finds the _next_ item with matching text and activates it.\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: 'o'\n   * user types: l\n   *\n   * activates Olive\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive (active), Orange, Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Orange\n   *\n   * @example\n   *\n   * items: Apple, Banana, Olive, Orange (active), Cucumber\n   * buffer: ''\n   * user types: o\n   *\n   * activates Olive\n   */\n  private typeahead(event: KeyboardEvent) {\n    if (event.defaultPrevented) return;\n    clearTimeout(this.cancelTypeaheadTimeout);\n    // Stop typingahead if one of the navigation or selection keys (except for\n    // Space) are pressed\n    if (event.code === 'Enter' || event.code.startsWith('Arrow') ||\n        event.code === 'Escape') {\n      this.endTypeahead();\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n      }\n      return;\n    }\n\n    // If Space is pressed, prevent it from selecting and closing the menu\n    if (event.code === 'Space') {\n      event.preventDefault();\n    }\n\n    // Start up a new keystroke buffer timeout\n    this.cancelTypeaheadTimeout =\n        setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);\n\n    this.typaheadBuffer += event.key.toLowerCase();\n\n    const lastActiveIndex = this.lastActiveRecord ?\n        this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] :\n        -1;\n    const numRecords = this.typeaheadRecords.length;\n\n    /**\n     * Sorting function that will resort the items starting with the given index\n     *\n     * @example\n     *\n     * this.typeaheadRecords =\n     * 0: [0, <reference>, 'apple']\n     * 1: [1, <reference>, 'apricot']\n     * 2: [2, <reference>, 'banana']\n     * 3: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 4: [4, <reference>, 'orange']\n     * 5: [5, <reference>, 'strawberry']\n     *\n     * this.typeaheadRecords.sort((a,b) => rebaseIndexOnActive(a)\n     *                                       - rebaseIndexOnActive(b)) ===\n     * 0: [3, <reference>, 'olive'] <-- lastActiveIndex\n     * 1: [4, <reference>, 'orange']\n     * 2: [5, <reference>, 'strawberry']\n     * 3: [0, <reference>, 'apple']\n     * 4: [1, <reference>, 'apricot']\n     * 5: [2, <reference>, 'banana']\n     */\n    const rebaseIndexOnActive = (record: TypeaheadRecord) => {\n      return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) %\n          numRecords;\n    };\n\n    // records filtered and sorted / rebased around the last active index\n    const matchingRecords =\n        this.typeaheadRecords\n            .filter(\n                record => !record[TYPEAHEAD_RECORD.ITEM].disabled &&\n                    record[TYPEAHEAD_RECORD.TEXT].startsWith(\n                        this.typaheadBuffer))\n            .sort((a, b) => rebaseIndexOnActive(a) - rebaseIndexOnActive(b));\n\n    // Just leave if there's nothing that matches. Native select will just\n    // choose the first thing that starts with the next letter in the alphabet\n    // but that's out of scope and hard to localize\n    if (matchingRecords.length === 0) {\n      clearTimeout(this.cancelTypeaheadTimeout);\n      if (this.lastActiveRecord) {\n        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n      }\n      this.endTypeahead();\n      return;\n    }\n\n    const isNewQuery = this.typaheadBuffer.length === 1;\n    let nextRecord: TypeaheadRecord;\n\n    // This is likely the case that someone is trying to \"tab\" through different\n    // entries that start with the same letter\n    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {\n      nextRecord = matchingRecords[1] ?? matchingRecords[0];\n    } else {\n      nextRecord = matchingRecords[0];\n    }\n\n    if (this.lastActiveRecord) {\n      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;\n    }\n\n    this.lastActiveRecord = nextRecord;\n    nextRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = 0;\n    nextRecord[TYPEAHEAD_RECORD.ITEM].focus();\n    return;\n  }\n\n  /**\n   * Ends the current typeahead and clears the buffer.\n   */\n  private readonly endTypeahead = () => {\n    this.isTypingAhead = false;\n    this.typaheadBuffer = '';\n    this.typeaheadRecords = [];\n  };\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../focus/md-focus-ring.js';\nimport '../../elevation/elevation.js';\n\nimport {html, isServer, LitElement, PropertyValues} from 'lit';\nimport {property, query, queryAssignedElements, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {polyfillElementInternalsAria, setupHostAria} from '../../internal/aria/aria.js';\nimport {createAnimationSignal, EASING} from '../../internal/motion/animation.js';\nimport {ListController, NavigableKeys} from '../../list/internal/list-controller.js';\nimport {getActiveItem, getFirstActivatableItem, getLastActivatableItem} from '../../list/internal/list-navigation-helpers.js';\n\nimport {MenuItem} from './controllers/menuItemController.js';\nimport {ActivateTypeaheadEvent, DeactivateTypeaheadEvent, FocusState, isClosableKey, isElementInSubtree} from './controllers/shared.js';\nimport {Corner, SurfacePositionController, SurfacePositionTarget} from './controllers/surfacePositionController.js';\nimport {TypeaheadController} from './controllers/typeaheadController.js';\n\nexport {Corner} from './controllers/surfacePositionController.js';\n\n/**\n * The default value for the typeahead buffer time in Milliseconds.\n */\nexport const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;\n\nconst submenuNavKeys = new Set<string>([\n  NavigableKeys.ArrowDown,\n  NavigableKeys.ArrowUp,\n  NavigableKeys.Home,\n  NavigableKeys.End,\n]);\n\nconst menuNavKeys = new Set<string>([\n  NavigableKeys.ArrowLeft,\n  NavigableKeys.ArrowRight,\n  ...submenuNavKeys,\n]);\n\n/**\n * Gets the currently focused element on the page.\n *\n * @param activeDoc The document or shadowroot from which to start the search.\n *    Defaults to `window.document`\n * @return Returns the currently deeply focused element or `null` if none.\n */\nfunction getFocusedElement(activeDoc: Document|ShadowRoot = document):\n    HTMLElement|null {\n  let activeEl = activeDoc.activeElement as HTMLElement | null;\n\n  // Check for activeElement in the case that an element with a shadow root host\n  // is currently focused.\n  while (activeEl && activeEl?.shadowRoot?.activeElement) {\n    activeEl = activeEl.shadowRoot.activeElement as HTMLElement | null;\n  }\n\n  return activeEl;\n}\n\n/**\n * @fires opening Fired before the opening animation begins\n * @fires opened Fired once the menu is open, after any animations\n * @fires closing Fired before the closing animation begins\n * @fires closed Fired once the menu is closed, after any animations\n */\nexport abstract class Menu extends LitElement {\n  static {\n    // We want to manage tabindex ourselves.\n    setupHostAria(Menu, {focusable: false});\n  }\n\n  @query('.menu') private readonly surfaceEl!: HTMLElement|null;\n  @query('slot') private readonly slotEl!: HTMLSlotElement|null;\n\n  /**\n   * The ID of the element in the same root node in which the menu should align\n   * to. Overrides setting `anchorElement = elementReference`.\n   *\n   * __NOTE__: anchor or anchorElement must either be an HTMLElement or resolve\n   * to an HTMLElement in order for menu to open.\n   */\n  @property() anchor = '';\n  /**\n   * Whether the positioning algorithim should calculate relative to the parent\n   * of the anchor element (absolute) or relative to the window (fixed).\n   *\n   * Examples for `position = 'fixed'`:\n   *\n   * - If there is no `position:relative` in the given parent tree and the\n   *   surface is `position:absolute`\n   * - If the surface is `position:fixed`\n   * - If the surface is in the \"top layer\"\n   * - The anchor and the surface do not share a common `position:relative`\n   *   ancestor\n   *\n   * When using positioning = fixed, in most cases, the menu should position\n   * itself above most other `position:absolute` or `position:fixed` elements\n   * when placed inside of them. e.g. using a menu inside of an `md-dialog`.\n   *\n   * __NOTE__: Fixed menus will not scroll with the page and will be fixed to\n   * the window instead.\n   */\n  @property() positioning: 'absolute'|'fixed' = 'absolute';\n  /**\n   * Skips the opening and closing animations.\n   */\n  @property({type: Boolean}) quick = false;\n  /**\n   * Displays overflow content like a submenu.\n   *\n   * __NOTE__: This may cause adverse effects if you set\n   * `md-menu {max-height:...}`\n   * and have items overflowing items in the \"y\" direction.\n   */\n  @property({type: Boolean, attribute: 'has-overflow'}) hasOverflow = false;\n  /**\n   * Opens the menu and makes it visible. Alternative to the `.show()` and\n   * `.close()` methods\n   */\n  @property({type: Boolean, reflect: true}) open = false;\n  /**\n   * Offsets the menu's inline alignment from the anchor by the given number in\n   * pixels. This value is direction aware and will follow the LTR / RTL\n   * direction.\n   *\n   * e.g. LTR: positive -> right, negative -> left\n   *      RTL: positive -> left, negative -> right\n   */\n  @property({type: Number, attribute: 'x-offset'}) xOffset = 0;\n  /**\n   * Offsets the menu's block alignment from the anchor by the given number in\n   * pixels.\n   *\n   * e.g. positive -> down, negative -> up\n   */\n  @property({type: Number, attribute: 'y-offset'}) yOffset = 0;\n  /**\n   * The max time between the keystrokes of the typeahead menu behavior before\n   * it clears the typeahead buffer.\n   */\n  @property({type: Number, attribute: 'typeahead-delay'})\n  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n  /**\n   * The corner of the anchor which to align the menu in the standard logical\n   * property style of <block>-<inline> e.g. `'end-start'`.\n   *\n   * NOTE: This value may not be respected by the menu positioning algorithm\n   * if the menu would render outisde the viewport.\n   */\n  @property({attribute: 'anchor-corner'})\n  anchorCorner: Corner = Corner.END_START;\n  /**\n   * The corner of the menu which to align the anchor in the standard logical\n   * property style of <block>-<inline> e.g. `'start-start'`.\n   *\n   * NOTE: This value may not be respected by the menu positioning algorithm\n   * if the menu would render outisde the viewport.\n   */\n  @property({attribute: 'menu-corner'}) menuCorner: Corner = Corner.START_START;\n  /**\n   * Keeps the user clicks outside the menu.\n   *\n   * NOTE: clicking outside may still cause focusout to close the menu so see\n   * `stayOpenOnFocusout`.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-outside-click'})\n  stayOpenOnOutsideClick = false;\n  /**\n   * Keeps the menu open when focus leaves the menu's composed subtree.\n   *\n   * NOTE: Focusout behavior will stop propagation of the focusout event. Set\n   * this property to true to opt-out of menu's focuout handling altogether.\n   */\n  @property({type: Boolean, attribute: 'stay-open-on-focusout'})\n  stayOpenOnFocusout = false;\n  /**\n   * After closing, does not restore focus to the last focused element before\n   * the menu was opened.\n   */\n  @property({type: Boolean, attribute: 'skip-restore-focus'})\n  skipRestoreFocus = false;\n  /**\n   * The element that should be focused by default once opened.\n   *\n   * NOTE: When setting default focus to 'LIST_ROOT', remember to change\n   * `tabindex` to `0` and change md-menu's display to something other than\n   * `display: contents` when necessary.\n   */\n  @property({attribute: 'default-focus'})\n  defaultFocus: FocusState = FocusState.FIRST_ITEM;\n\n  @queryAssignedElements({flatten: true}) protected slotItems!: HTMLElement[];\n  @state() private typeaheadActive = true;\n\n  /**\n   * Whether or not the current menu is a submenu and should not handle specific\n   * navigation keys.\n   *\n   * @exports\n   */\n  isSubmenu = false;\n\n  /**\n   * The event path of the last window pointerdown event.\n   */\n  private pointerPath: EventTarget[] = [];\n  private readonly openCloseAnimationSignal = createAnimationSignal();\n\n  private readonly listController = new ListController<MenuItem>({\n    isItem: (maybeItem: HTMLElement): maybeItem is MenuItem => {\n      return maybeItem.hasAttribute('md-menu-item');\n    },\n    getPossibleItems: () => this.slotItems,\n    isRtl: () => (getComputedStyle(this).direction === 'rtl'),\n    deactivateItem:\n        (item: MenuItem) => {\n          item.selected = false;\n          item.tabIndex = -1;\n        },\n    activateItem:\n        (item: MenuItem) => {\n          item.selected = true;\n          item.tabIndex = 0;\n        },\n    isNavigableKey:\n        (key: string) => {\n          if (!this.isSubmenu) {\n            return menuNavKeys.has(key);\n          }\n\n          const isRtl = getComputedStyle(this).direction === 'rtl';\n          // we want md-submenu to handle the submenu's left/right arrow exit\n          // key so it can close the menu instead of navigate the list.\n          // Therefore we need to include all keys but left/right arrow close\n          // key\n          const arrowOpen =\n              isRtl ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;\n\n          if (key === arrowOpen) {\n            return true;\n          }\n\n          return submenuNavKeys.has(key);\n        },\n  });\n\n  /**\n   * Whether the menu is animating upwards or downwards when opening. This is\n   * helpful for calculating some animation calculations.\n   */\n  private get openDirection(): 'UP'|'DOWN' {\n    const menuCornerBlock = this.menuCorner.split('-')[0];\n    return menuCornerBlock === 'start' ? 'DOWN' : 'UP';\n  }\n\n  /**\n   * The element that was focused before the menu opened.\n   */\n  private lastFocusedElement: HTMLElement|null = null;\n\n  /**\n   * Handles typeahead navigation through the menu.\n   */\n  typeaheadController = new TypeaheadController(() => {\n    return {\n      getItems: () => this.items,\n      typeaheadBufferTime: this.typeaheadDelay,\n      active: this.typeaheadActive\n    };\n  });\n\n  private currentAnchorElement: HTMLElement|null = null;\n\n  /**\n   * The element which the menu should align to. If `anchor` is set to a\n   * non-empty idref string, then `anchorEl` will resolve to the element with\n   * the given id in the same root node. Otherwise, `null`.\n   */\n  get anchorElement(): HTMLElement&Partial<SurfacePositionTarget>|null {\n    if (this.anchor) {\n      return (this.getRootNode() as Document | ShadowRoot)\n          .querySelector(`#${this.anchor}`);\n    }\n\n    return this.currentAnchorElement;\n  }\n\n  set anchorElement(element: HTMLElement&Partial<SurfacePositionTarget>|null) {\n    this.currentAnchorElement = element;\n    this.requestUpdate('anchorElement');\n  }\n\n  private readonly internals = polyfillElementInternalsAria(\n      this, (this as HTMLElement /* needed for closure */).attachInternals());\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.internals.role = 'menu';\n      this.addEventListener('keydown', this.handleKeydown);\n      // Capture so that we can grab the event before it reaches the menu item\n      // istelf. Specifically useful for the case where typeahead encounters a\n      // space and we don't want the menu item to close the menu.\n      this.addEventListener('keydown', this.captureKeydown, {capture: true});\n      this.addEventListener('focusout', this.handleFocusout);\n    }\n  }\n\n  /**\n   * Handles positioning the surface and aligning it to the anchor as well as\n   * keeping it in the viewport.\n   */\n  private readonly menuPositionController =\n      new SurfacePositionController(this, () => {\n        return {\n          anchorCorner: this.anchorCorner,\n          surfaceCorner: this.menuCorner,\n          surfaceEl: this.surfaceEl,\n          anchorEl: this.anchorElement,\n          positioning: this.positioning,\n          isOpen: this.open,\n          xOffset: this.xOffset,\n          yOffset: this.yOffset,\n          onOpen: this.onOpened,\n          beforeClose: this.beforeClose,\n          onClose: this.onClosed,\n          // We can't resize components that have overflow like menus with\n          // submenus because the overflow-y will show menu items / content\n          // outside the bounds of the menu. (to be fixed w/ popover API)\n          repositionStrategy: this.hasOverflow ? 'move' : 'resize',\n        };\n      });\n\n  /**\n   * The menu items associated with this menu. The items must be `MenuItem`s and\n   * have both the `md-menu-item` and `md-list-item` attributes.\n   */\n  get items(): MenuItem[] {\n    return this.listController.items;\n  }\n\n  protected override willUpdate(changed: PropertyValues<Menu>) {\n    if (!changed.has('open')) {\n      return;\n    }\n\n    if (this.open) {\n      this.removeAttribute('aria-hidden');\n      return;\n    }\n\n    this.setAttribute('aria-hidden', 'true');\n  }\n\n  override update(changed: PropertyValues<Menu>) {\n    if (changed.has('open')) {\n      if (this.open) {\n        this.setUpGlobalEventListeners();\n      } else {\n        this.cleanUpGlobalEventListeners();\n      }\n    }\n\n    super.update(changed);\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    if (this.open) {\n      this.setUpGlobalEventListeners();\n    }\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    this.cleanUpGlobalEventListeners();\n  }\n\n  protected override render() {\n    return this.renderSurface();\n  }\n\n  /**\n   * Renders the positionable surface element and its contents.\n   */\n  private renderSurface() {\n    return html`\n       <div\n          class=\"menu ${classMap(this.getSurfaceClasses())}\"\n          style=${styleMap(this.menuPositionController.surfaceStyles)}>\n        ${this.renderElevation()}\n        <div class=\"items\">\n          <div class=\"item-padding\">\n            ${this.renderMenuItems()}\n          </div>\n        </div>\n       </div>\n     `;\n  }\n\n  /**\n   * Renders the menu items' slot\n   */\n  private renderMenuItems() {\n    return html`<slot\n        @close-menu=${this.onCloseMenu}\n        @deactivate-items=${this.onDeactivateItems}\n        @request-activation=${this.onRequestActivation}\n        @deactivate-typeahead=${this.handleDeactivateTypeahead}\n        @activate-typeahead=${this.handleActivateTypeahead}\n        @stay-open-on-focusout=${this.handleStayOpenOnFocusout}\n        @close-on-focusout=${this.handleCloseOnFocusout}\n        @slotchange=${this.listController.onSlotchange}></slot>`;\n  }\n\n  /**\n   * Renders the elevation component.\n   */\n  private renderElevation() {\n    return html`<md-elevation part=\"elevation\"></md-elevation>`;\n  }\n\n  private getSurfaceClasses() {\n    return {\n      open: this.open,\n      fixed: this.positioning === 'fixed',\n      'has-overflow': this.hasOverflow,\n    };\n  }\n\n  private readonly handleFocusout = async (event: FocusEvent) => {\n    const anchorEl = this.anchorElement!;\n    // Do not close if we focused out by clicking on the anchor element. We\n    // can't assume anchor buttons can be the related target because of iOS does\n    // not focus buttons.\n    if (this.stayOpenOnFocusout || !this.open ||\n        this.pointerPath.includes(anchorEl)) {\n      return;\n    }\n\n    if (event.relatedTarget) {\n      // Don't close the menu if we are switching focus between menu,\n      // md-menu-item, and md-list or if the anchor was click focused.\n      if (isElementInSubtree(event.relatedTarget, this) ||\n          isElementInSubtree(event.relatedTarget, anchorEl)) {\n        return;\n      }\n    } else if (this.pointerPath.includes(this)) {\n      // If menu tabindex == -1 and the user clicks on the menu or a divider, we\n      // want to keep the menu open.\n      return;\n    }\n\n    const oldRestoreFocus = this.skipRestoreFocus;\n    // allow focus to continue to the next focused object rather than returning\n    this.skipRestoreFocus = true;\n    this.close();\n    // await for close\n    await this.updateComplete;\n    // return to previous behavior\n    this.skipRestoreFocus = oldRestoreFocus;\n  };\n\n  private captureKeydown(event: KeyboardEvent) {\n    if (event.target === this && !event.defaultPrevented &&\n        isClosableKey(event.code)) {\n      event.preventDefault();\n      this.close();\n    }\n\n    this.typeaheadController.onKeydown(event);\n  }\n\n  /**\n   * Saves the last focused element focuses the new element based on\n   * `defaultFocus`, and animates open.\n   */\n  private readonly onOpened = async () => {\n    this.lastFocusedElement = getFocusedElement();\n\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items);\n\n    if (activeItemRecord && this.defaultFocus !== FocusState.NONE) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n\n    let animationAborted = !this.quick;\n\n    if (this.quick) {\n      this.dispatchEvent(new Event('opening'));\n    } else {\n      animationAborted = !!await this.animateOpen();\n    }\n\n    // This must come after the opening animation or else it may focus one of\n    // the items before the animation has begun and causes the list to slide\n    // (block-padding-of-the-menu)px at the end of the animation\n    switch (this.defaultFocus) {\n      case FocusState.FIRST_ITEM:\n        const first = getFirstActivatableItem(items);\n        if (first) {\n          first.tabIndex = 0;\n          first.focus();\n          await (first as LitElement & MenuItem).updateComplete;\n        }\n        break;\n      case FocusState.LAST_ITEM:\n        const last = getLastActivatableItem(items);\n        if (last) {\n          last.tabIndex = 0;\n          last.focus();\n          await (last as LitElement & MenuItem).updateComplete;\n        }\n        break;\n      case FocusState.LIST_ROOT:\n        this.focus();\n        break;\n      default:\n      case FocusState.NONE:\n        // Do nothing.\n        break;\n    }\n\n    if (!animationAborted) {\n      this.dispatchEvent(new Event('opened'));\n    }\n  };\n\n  /**\n   * Animates closed.\n   */\n  private readonly beforeClose = async () => {\n    this.open = false;\n\n    if (!this.skipRestoreFocus) {\n      this.lastFocusedElement?.focus?.();\n    }\n\n    if (!this.quick) {\n      await this.animateClose();\n    }\n  };\n\n  /**\n   * Focuses the last focused element.\n   */\n  private readonly onClosed = () => {\n    if (this.quick) {\n      this.dispatchEvent(new Event('closing'));\n      this.dispatchEvent(new Event('closed'));\n    }\n  };\n\n  /**\n   * Performs the opening animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   *\n   * @return A promise that resolve to `true` if the animation was aborted,\n   *     `false` if it was not aborted.\n   */\n  private async animateOpen() {\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) return true;\n\n    const openDirection = this.openDirection;\n    this.dispatchEvent(new Event('opening'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const openingUpwards = openDirection === 'UP';\n    const children = this.items;\n    const FULL_DURATION = 500;\n    const SURFACE_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_DURATION = 250;\n    // We want to fit every child fade-in animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;\n\n    const surfaceHeightAnimation =\n        surfaceEl.animate([{height: '0px'}, {height: `${height}px`}], {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED,\n        });\n    // When we are opening upwards, we want to make sure the last item is always\n    // in view, so we need to translate it upwards the opposite direction of the\n    // height animation\n    const upPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: openingUpwards ? `translateY(-${height}px)` : ''},\n          {transform: ''}\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 0}, {opacity: 1}], SURFACE_OPACITY_DURATION);\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If we are animating upwards, then reverse the children list.\n      const directionalIndex = openingUpwards ? children.length - 1 - i : i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 0}, {opacity: 1}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make them all initially hidden and then clean up at the end of each\n      // animation.\n      child.classList.toggle('md-menu-hidden', true);\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('md-menu-hidden', false);\n      });\n\n      childrenAnimations.push([child, animation]);\n    }\n\n    let resolveAnimation = (value: boolean) => {};\n    const animationFinished = new Promise<boolean>((resolve) => {\n      resolveAnimation = resolve;\n    });\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      upPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        child.classList.toggle('md-menu-hidden', false);\n        animation.cancel();\n      });\n\n      resolveAnimation(true);\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      this.openCloseAnimationSignal.finish();\n      resolveAnimation(false);\n    });\n\n    return await animationFinished;\n  }\n\n  /**\n   * Performs the closing animation:\n   *\n   * https://direct.googleplex.com/#/spec/295000003+271060003\n   */\n  private animateClose() {\n    let resolve!: (value: unknown) => void;\n    let reject!: () => void;\n\n    // This promise blocks the surface position controller from setting\n    // display: none on the surface which will interfere with this animation.\n    const animationEnded = new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const surfaceEl = this.surfaceEl;\n    const slotEl = this.slotEl;\n\n    if (!surfaceEl || !slotEl) {\n      reject();\n      return animationEnded;\n    }\n\n    const openDirection = this.openDirection;\n    const closingDownwards = openDirection === 'UP';\n    this.dispatchEvent(new Event('closing'));\n    // needs to be imperative because we don't want to mix animation and Lit\n    // render timing\n    surfaceEl.classList.toggle('animating', true);\n    const signal = this.openCloseAnimationSignal.start();\n    const height = surfaceEl.offsetHeight;\n    const children = this.items;\n    const FULL_DURATION = 150;\n    const SURFACE_OPACITY_DURATION = 50;\n    // The surface fades away at the very end\n    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;\n    const ITEM_OPACITY_DURATION = 50;\n    const ITEM_OPACITY_INITIAL_DELAY = 50;\n    const END_HEIGHT_PERCENTAGE = .35;\n\n    // We want to fit every child fade-out animation within the full duration of\n    // the animation.\n    const DELAY_BETWEEN_ITEMS =\n        (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) /\n        children.length;\n\n    // The mock has the animation shrink to 35%\n    const surfaceHeightAnimation = surfaceEl.animate(\n        [\n          {height: `${height}px`},\n          {height: `${height * END_HEIGHT_PERCENTAGE}px`}\n        ],\n        {\n          duration: FULL_DURATION,\n          easing: EASING.EMPHASIZED_ACCELERATE,\n        });\n\n    // When we are closing downwards, we want to make sure the last item is\n    // always in view, so we need to translate it upwards the opposite direction\n    // of the height animation\n    const downPositionCorrectionAnimation = slotEl.animate(\n        [\n          {transform: ''}, {\n            transform: closingDownwards ?\n                `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` :\n                ''\n          }\n        ],\n        {duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE});\n\n    const surfaceOpacityAnimation = surfaceEl.animate(\n        [{opacity: 1}, {opacity: 0}],\n        {duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY});\n\n    const childrenAnimations: Array<[HTMLElement, Animation]> = [];\n\n    for (let i = 0; i < children.length; i++) {\n      // If the animation is closing upwards, then reverse the list of\n      // children so that we animate in the opposite direction.\n      const directionalIndex = closingDownwards ? i : children.length - 1 - i;\n      const child = children[directionalIndex];\n      const animation = child.animate([{opacity: 1}, {opacity: 0}], {\n        duration: ITEM_OPACITY_DURATION,\n        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i,\n      });\n\n      // Make sure the items stay hidden at the end of each child animation.\n      // We clean this up at the end of the overall animation.\n      animation.addEventListener('finish', () => {\n        child.classList.toggle('md-menu-hidden', true);\n      });\n      childrenAnimations.push([child, animation]);\n    }\n\n    signal.addEventListener('abort', () => {\n      surfaceHeightAnimation.cancel();\n      downPositionCorrectionAnimation.cancel();\n      surfaceOpacityAnimation.cancel();\n      childrenAnimations.forEach(([child, animation]) => {\n        animation.cancel();\n        child.classList.toggle('md-menu-hidden', false);\n      });\n      reject();\n    });\n\n    surfaceHeightAnimation.addEventListener('finish', () => {\n      surfaceEl.classList.toggle('animating', false);\n      childrenAnimations.forEach(([child]) => {\n        child.classList.toggle('md-menu-hidden', false);\n      });\n      this.openCloseAnimationSignal.finish();\n      this.dispatchEvent(new Event('closed'));\n      resolve(true);\n    });\n\n    return animationEnded;\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    // At any key event, the pointer interaction is done so we need to clear our\n    // cached pointerpath. This handles the case where the user clicks on the\n    // anchor, and then hits shift+tab\n    this.pointerPath = [];\n    this.listController.handleKeydown(event);\n  }\n\n  private setUpGlobalEventListeners() {\n    document.addEventListener('click', this.onDocumentClick, {capture: true});\n    window.addEventListener('pointerdown', this.onWindowPointerdown);\n  }\n\n  private cleanUpGlobalEventListeners() {\n    document.removeEventListener(\n        'click', this.onDocumentClick, {capture: true});\n    window.removeEventListener('pointerdown', this.onWindowPointerdown);\n  }\n\n  private readonly onWindowPointerdown = (event: PointerEvent) => {\n    this.pointerPath = event.composedPath();\n  };\n\n  /**\n   * We cannot listen to window click because Safari on iOS will not bubble a\n   * click event on window if the item clicked is not a \"clickable\" item such as\n   * <body>\n   */\n  private readonly onDocumentClick = (event: Event) => {\n    if (!this.open) {\n      return;\n    }\n\n    const path = event.composedPath();\n\n    if (!this.stayOpenOnOutsideClick && !path.includes(this) &&\n        !path.includes(this.anchorElement!)) {\n      this.open = false;\n    }\n  };\n\n  private onCloseMenu() {\n    this.close();\n  }\n\n  private onDeactivateItems(event: Event) {\n    event.stopPropagation();\n    this.listController.onDeactivateItems();\n  }\n\n  private onRequestActivation(event: Event) {\n    event.stopPropagation();\n    this.listController.onRequestActivation(event);\n  }\n\n  private handleDeactivateTypeahead(event: DeactivateTypeaheadEvent) {\n    // stopPropagation so that this does not deactivate any typeaheads in menus\n    // nested above it e.g. md-sub-menu\n    event.stopPropagation();\n    this.typeaheadActive = false;\n  }\n\n  private handleActivateTypeahead(event: ActivateTypeaheadEvent) {\n    // stopPropagation so that this does not activate any typeaheads in menus\n    // nested above it e.g. md-sub-menu\n    event.stopPropagation();\n    this.typeaheadActive = true;\n  }\n\n  private handleStayOpenOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = true;\n  }\n\n  private handleCloseOnFocusout(event: Event) {\n    event.stopPropagation();\n    this.stayOpenOnFocusout = false;\n  }\n\n  close() {\n    this.open = false;\n    const maybeSubmenu =\n        this.slotItems as Array<HTMLElement&{close?: () => void}>;\n    maybeSubmenu.forEach(item => {\n      item.close?.();\n    });\n  }\n\n  show() {\n    this.open = true;\n  }\n\n  /**\n   * Activates the next item in the menu. If at the end of the menu, the first\n   * item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activateNextItem() {\n    return this.listController.activateNextItem() ?? null;\n  }\n\n  /**\n   * Activates the previous item in the menu. If at the start of the menu, the\n   * last item will be activated.\n   *\n   * @return The activated menu item or `null` if there are no items.\n   */\n  activatePreviousItem() {\n    return this.listController.activatePreviousItem() ?? null;\n  }\n}\n", "/**\n  * @license\n  * Copyright 2022 Google LLC\n  * SPDX-License-Identifier: Apache-2.0\n  */\n import {css} from 'lit';\n export const styles = css`:host{--md-elevation-level: var(--md-menu-container-elevation, 2);--md-elevation-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));min-width:112px;color:unset;display:contents}md-focus-ring{--md-focus-ring-shape: var(--md-menu-container-shape, 4px)}.menu{border-radius:var(--md-menu-container-shape, 4px);display:none;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit;max-width:inherit}.fixed{position:fixed}.items{display:block;list-style-type:none;margin:0;outline:none;box-sizing:border-box;background-color:var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));height:inherit;max-height:inherit;overflow:auto;min-width:inherit;max-width:inherit;border-radius:inherit}.item-padding{padding-block:8px}.has-overflow .items{overflow:visible}.animating .items{overflow:hidden}.has-overflow.animating .items{pointer-events:none}.animating ::slotted(.md-menu-hidden){opacity:0}slot{display:block;height:inherit;max-height:inherit}::slotted(:is(md-divider,[role=separator])){margin:8px 0}@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}/*# sourceMappingURL=menu-styles.css.map */\n`;\n ", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {customElement} from 'lit/decorators.js';\n\nimport {Menu} from './internal/menu.js';\nimport {styles} from './internal/menu-styles.css.js';\n\nexport {ListItem} from '../list/internal/list-navigation-helpers.js';\nexport {MenuItem} from './internal/controllers/menuItemController.js';\nexport {CloseMenuEvent, FocusState, Menu} from './internal/controllers/shared.js';\nexport {Corner} from './internal/menu.js';\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'md-menu': MdMenu;\n  }\n}\n\n/**\n * @summary Menus display a list of choices on a temporary surface.\n *\n * @description\n * Menus appear when users interact with a button, action, or other control.\n *\n * They can be opened from a variety of elements, most commonly icon buttons,\n * buttons, and text fields.\n *\n * md-menu listens for the `close-menu` and `deselect-items` events.\n *\n * - `close-menu` closes the menu when dispatched from a child element.\n * - `deselect-items` deselects all of its immediate menu-item children.\n *\n * @example\n * ```html\n * <div style=\"position:relative;\">\n *   <button\n *       id=\"anchor\"\n *       @click=${() => this.menuRef.value.show()}>\n *     Click to open menu\n *   </button>\n *   <!--\n *     `has-overflow` is required when using a submenu which overflows the\n *     menu's contents.\n *\n *     Additionally, `anchor` ingests an idref which do not pass through shadow\n *     roots. You can also set `.anchorElement` to an element reference if\n *     necessary.\n *   -->\n *   <md-menu anchor=\"anchor\" has-overflow ${ref(menuRef)}>\n *     <md-menu-item headline=\"This is a headline\"></md-menu-item>\n *     <md-sub-menu>\n *       <md-menu-item\n *           slot=\"item\"\n *           headline=\"this is a submenu item\">\n *       </md-menu-item>\n *       <md-menu slot=\"menu\">\n *         <md-menu-item headline=\"This is an item inside a submenu\">\n *         </md-menu-item>\n *       </md-menu>\n *     </md-sub-menu>\n *   </md-menu>\n * </div>\n * ```\n *\n * @final\n * @suppress {visibility}\n */\n@customElement('md-menu')\nexport class MdMenu extends Menu {\n  static override styles = [styles];\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {SelectOption} from './selectoption/selectOptionController.js';\n\n/**\n * A type that describes a SelectOption and its index.\n */\nexport type SelectOptionRecord = [SelectOption, number];\n\n/**\n * Given a list of select options, this function will return an array of\n * SelectOptionRecords that are selected.\n *\n * @return An array of SelectOptionRecords describing the options that are\n * selected.\n */\nexport function getSelectedItems(items: SelectOption[]) {\n  const selectedItemRecords: SelectOptionRecord[] = [];\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (item.selected) {\n      selectedItemRecords.push([item, i]);\n    }\n  }\n\n  return selectedItemRecords;\n}\n", "/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../menu/menu.js';\n\nimport {html, isServer, LitElement, nothing, PropertyValues} from 'lit';\nimport {property, query, queryAssignedElements, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {html as staticHtml, StaticValue} from 'lit/static-html.js';\n\nimport {Field} from '../../field/internal/field.js';\nimport {ARIAMixinStrict} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {redispatchEvent} from '../../internal/controller/events.js';\nimport {getActiveItem} from '../../list/internal/list-navigation-helpers.js';\nimport {CloseMenuEvent, isElementInSubtree, isSelectableKey} from '../../menu/internal/controllers/shared.js';\nimport {TYPEAHEAD_RECORD} from '../../menu/internal/controllers/typeaheadController.js';\nimport {DEFAULT_TYPEAHEAD_BUFFER_TIME, Menu} from '../../menu/internal/menu.js';\n\nimport {createRequestDeselectionEvent, createRequestSelectionEvent, SelectOption} from './selectoption/selectOptionController.js';\nimport {getSelectedItems, SelectOptionRecord} from './shared.js';\n\nconst VALUE = Symbol('value');\n\n/**\n * @fires input Fired when a selection is made by the user via mouse or keyboard\n * interaction.\n * @fires change Fired when a selection is made by the user via mouse or\n * keyboard interaction.\n * @fires opening Fired when the select's menu is about to open.\n * @fires opened Fired when the select's menu has finished animations and\n * opened.\n * @fires closing Fired when the select's menu is about to close.\n * @fires closed Fired when the select's menu has finished animations and\n * closed.\n */\nexport abstract class Select extends LitElement {\n  static {\n    requestUpdateOnAriaChange(Select);\n  }\n\n  /** @nocollapse  */\n  static readonly formAssociated = true;\n\n  /**\n   * Opens the menu synchronously with no animation.\n   */\n  @property({type: Boolean}) quick = false;\n  /**\n   * Whether or not the select is required.\n   */\n  @property({type: Boolean}) required = false;\n  /**\n   * Disables the select.\n   */\n  @property({type: Boolean, reflect: true}) disabled = false;\n  /**\n   * The error message that replaces supporting text when `error` is true. If\n   * `errorText` is an empty string, then the supporting text will continue to\n   * show.\n   *\n   * This error message overrides the error message displayed by\n   * `reportValidity()`.\n   */\n  @property({type: String, attribute: 'error-text'}) errorText = '';\n  /**\n   * The floating label for the field.\n   */\n  @property() label = '';\n  /**\n   * Conveys additional information below the select, such as how it should\n   * be used.\n   */\n  @property({type: String, attribute: 'supporting-text'}) supportingText = '';\n  /**\n   * Gets or sets whether or not the select is in a visually invalid state.\n   *\n   * This error state overrides the error state controlled by\n   * `reportValidity()`.\n   */\n  @property({type: Boolean, reflect: true}) error = false;\n  /**\n   * Whether or not the underlying md-menu should be position: fixed to display\n   * in a top-level manner, or position: absolute.\n   *\n   * position:fixed is useful for cases where select is inside of another\n   * element with stacking context and hidden overflows such as `md-dialog`.\n   */\n  @property({attribute: 'menu-positioning'})\n  menuPositioning: 'absolute'|'fixed' = 'absolute';\n  /**\n   * The max time between the keystrokes of the typeahead select / menu behavior\n   * before it clears the typeahead buffer.\n   */\n  @property({type: Number, attribute: 'typeahead-delay'})\n  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;\n  /**\n   * Whether or not the text field has a leading icon. Used for SSR.\n   */\n  @property({type: Boolean, attribute: 'has-leading-icon'})\n  hasLeadingIcon = false;\n  /**\n   * Text to display in the field. Only set for SSR.\n   */\n  @property({attribute: 'display-text'}) displayText = '';\n\n  /**\n   * The value of the currently selected option.\n   *\n   * Note: For SSR, set `[selected]` on the requested option and `displayText`\n   * rather than setting `value` setting `value` will incur a DOM query.\n   */\n  @property()\n  get value(): string {\n    return this[VALUE];\n  }\n\n  set value(value: string) {\n    if (isServer) return;\n    this.lastUserSetValue = value;\n    this.select(value);\n  }\n\n  [VALUE] = '';\n\n  get options() {\n    // NOTE: this does a DOM query.\n    return (this.menu?.items ?? []) as SelectOption[];\n  }\n\n  /**\n   * The index of the currently selected option.\n   *\n   * Note: For SSR, set `[selected]` on the requested option and `displayText`\n   * rather than setting `selectedIndex` setting `selectedIndex` will incur a\n   * DOM query.\n   */\n  @property({type: Number, attribute: 'selected-index'})\n  get selectedIndex(): number {\n    // tslint:disable-next-line:enforce-name-casing\n    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];\n    return index ?? -1;\n  }\n\n  set selectedIndex(index: number) {\n    this.lastUserSetSelectedIndex = index;\n    this.selectIndex(index);\n  }\n\n  /**\n   * Returns an array of selected options.\n   *\n   * NOTE: md-select only suppoprts single selection.\n   */\n  get selectedOptions() {\n    return (this.getSelectedOptions() ?? []).map(([option]) => option);\n  }\n\n  /**\n   * The HTML name to use in form submission.\n   */\n  get name() {\n    return this.getAttribute('name') ?? '';\n  }\n  set name(name: string) {\n    this.setAttribute('name', name);\n  }\n\n  /**\n   * The associated form element with which this element's value will submit.\n   */\n  get form() {\n    return this.internals.form;\n  }\n\n  /**\n   * The labels this element is associated with.\n   */\n  get labels() {\n    return this.internals.labels;\n  }\n\n  /**\n   * Returns a ValidityState object that represents the validity states of the\n   * checkbox.\n   *\n   * Note that selects will only set `valueMissing` if unselected and\n   * `required`.\n   */\n  get validity() {\n    this.syncValidity();\n    return this.internals.validity;\n  }\n\n  /**\n   * Returns the native validation error message.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation#constraint_validation_process\n   */\n  get validationMessage() {\n    this.syncValidity();\n    return this.internals.validationMessage;\n  }\n\n  /**\n   * Returns whether an element will successfully validate based on forms\n   * validation rules and constraints.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation#constraint_validation_process\n   */\n  get willValidate() {\n    this.syncValidity();\n    return this.internals.willValidate;\n  }\n\n  protected abstract readonly fieldTag: StaticValue;\n\n  /**\n   * Used for initializing select when the user sets the `value` directly.\n   */\n  private lastUserSetValue: string|null = null;\n\n  /**\n   * Used for initializing select when the user sets the `selectedIndex`\n   * directly.\n   */\n  private lastUserSetSelectedIndex: number|null = null;\n\n  /**\n   * Used for `input` and `change` event change detection.\n   */\n  private lastSelectedOption: SelectOption|null = null;\n\n  // tslint:disable-next-line:enforce-name-casing\n  private lastSelectedOptionRecords: SelectOptionRecord[] = [];\n\n  /**\n   * Whether or not a native error has been reported via `reportValidity()`.\n   */\n  @state() private nativeError = false;\n\n  /**\n   * The validation message displayed from a native error via\n   * `reportValidity()`.\n   */\n  @state() private nativeErrorText = '';\n  private get hasError() {\n    return this.error || this.nativeError;\n  }\n\n  @state() private focused = false;\n  @state() private open = false;\n  @query('.field') private readonly field!: Field|null;\n  @query('md-menu') private readonly menu!: Menu|null;\n  @query('#label') private readonly labelEl!: HTMLElement;\n  @queryAssignedElements({slot: 'leading-icon', flatten: true})\n  private readonly leadingIcons!: Element[];\n  private customValidationMessage = '';\n  private readonly internals =\n      (this as HTMLElement /* needed for closure */).attachInternals();\n\n  /**\n   * Selects an option given the value of the option, and updates MdSelect's\n   * value.\n   */\n  select(value: string) {\n    const optionToSelect = this.options.find(option => option.value === value);\n    if (optionToSelect) {\n      this.selectItem(optionToSelect);\n    }\n  }\n\n  /**\n   * Selects an option given the index of the option, and updates MdSelect's\n   * value.\n   */\n  selectIndex(index: number) {\n    const optionToSelect = this.options[index];\n    if (optionToSelect) {\n      this.selectItem(optionToSelect);\n    }\n  }\n\n  /**\n   * Reset the select to its default value.\n   */\n  reset() {\n    for (const option of this.options) {\n      option.selected = option.hasAttribute('selected');\n    }\n\n    this.updateValueAndDisplayText();\n    this.nativeError = false;\n    this.nativeErrorText = '';\n  }\n\n  /**\n   * Checks the select's native validation and returns whether or not the\n   * element is valid.\n   *\n   * If invalid, this method will dispatch the `invalid` event.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement/checkValidity\n   *\n   * @return true if the select is valid, or false if not.\n   */\n  checkValidity() {\n    this.syncValidity();\n    return this.internals.checkValidity();\n  }\n\n  /**\n   * Checks the select's native validation and returns whether or not the\n   * element is valid.\n   *\n   * If invalid, this method will dispatch the `invalid` event.\n   *\n   * This method will display or clear an error text message equal to the\n   * select's `validationMessage`, unless the invalid event is canceled.\n   *\n   * Use `setCustomValidity()` to customize the `validationMessage`.\n   *\n   * This method can also be used to re-announce error messages to screen\n   * readers.\n   *\n   * @return true if the select is valid, or false if not.\n   */\n  reportValidity() {\n    let invalidEvent: Event|undefined;\n    this.addEventListener('invalid', event => {\n      invalidEvent = event;\n    }, {once: true});\n\n    const valid = this.checkValidity();\n    if (invalidEvent?.defaultPrevented) {\n      return valid;\n    }\n\n    const prevMessage = this.getErrorText();\n    this.nativeError = !valid;\n    this.nativeErrorText = this.validationMessage;\n\n    if (prevMessage === this.getErrorText()) {\n      this.field?.reannounceError();\n    }\n\n    return valid;\n  }\n\n  /**\n   * Sets the select's native validation error message. This is used to\n   * customize `validationMessage`.\n   *\n   * When the error is not an empty string, the select is considered invalid\n   * and `validity.customError` will be true.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLSelectElement/setCustomValidity\n   *\n   * @param error The error message to display.\n   */\n  setCustomValidity(error: string) {\n    this.customValidationMessage = error;\n    this.syncValidity();\n  }\n\n  protected override update(changed: PropertyValues<Select>) {\n    // In SSR the options will be ready to query, so try to figure out what\n    // the value and display text should be.\n    if (!this.hasUpdated) {\n      this.initUserSelection();\n    }\n\n    super.update(changed);\n  }\n\n  protected override render() {\n    return html`\n      <span\n          class=\"select ${classMap(this.getRenderClasses())}\"\n          @focusout=${this.handleFocusout}>\n        ${this.renderField()}\n        ${this.renderMenu()}\n      </span>\n    `;\n  }\n\n  protected override updated(changed: PropertyValues<Select>) {\n    if (changed.has('required')) {\n      this.syncValidity();\n    }\n  }\n\n  protected override async firstUpdated(changed: PropertyValues<Select>) {\n    await this.menu?.updateComplete;\n    // If this has been handled on update already due to SSR, try again.\n    if (!this.lastSelectedOptionRecords.length) {\n      this.initUserSelection();\n    }\n\n    // Case for when the DOM is streaming, there are no children, and a child\n    // has [selected] set on it, we need to wait for DOM to render something.\n    if (!this.lastSelectedOptionRecords.length && !isServer &&\n        !this.options.length) {\n      setTimeout(() => {\n        this.updateValueAndDisplayText();\n      });\n    }\n\n    super.firstUpdated(changed);\n  }\n\n  private getRenderClasses() {\n    return {\n      'disabled': this.disabled,\n      'error': this.error,\n      'open': this.open,\n    };\n  }\n\n  private renderField() {\n    // TODO(b/290078041): add aria-label/describedby\n    return staticHtml`\n      <${this.fieldTag}\n          aria-haspopup=\"listbox\"\n          role=\"combobox\"\n          part=\"field\"\n          id=\"field\"\n          tabindex=${this.disabled ? '-1' : '0'}\n          aria-label=${(this as ARIAMixinStrict).ariaLabel || nothing}\n          aria-describedby=\"description\"\n          aria-expanded=${this.open ? 'true' : nothing}\n          aria-controls=\"listbox\"\n          class=\"field\"\n          label=${this.label}\n          .focused=${this.focused || this.open}\n          .populated=${!!this.displayText}\n          .disabled=${this.disabled}\n          .required=${this.required}\n          .error=${this.hasError}\n          ?has-start=${this.hasLeadingIcon}\n          has-end\n          supporting-text=${this.supportingText}\n          error-text=${this.getErrorText()}\n          @keydown=${this.handleKeydown}\n          @click=${this.handleClick}\n          @focus=${this.handleFocus}\n          @blur=${this.handleBlur}>\n         ${this.renderFieldContent()}\n         <div id=\"description\" slot=\"aria-describedby\"></div>\n      </${this.fieldTag}>`;\n  }\n\n  private renderFieldContent() {\n    return [\n      this.renderLeadingIcon(),\n      this.renderLabel(),\n      this.renderTrailingIcon(),\n    ];\n  }\n\n  private renderLeadingIcon() {\n    return html`\n      <span class=\"icon leading\" slot=\"start\">\n         <slot name=\"leading-icon\" @slotchange=${this.handleIconChange}></slot>\n      </span>\n     `;\n  }\n\n  private renderTrailingIcon() {\n    return html`\n      <span class=\"icon trailing\" slot=\"end\">\n        <slot name=\"trailing-icon\" @slotchange=${this.handleIconChange}>\n          <svg height=\"5\" viewBox=\"7 10 10 5\" focusable=\"false\">\n            <polygon class=\"down\" stroke=\"none\" fill-rule=\"evenodd\" points=\"7 10 12 15 17 10\"></polygon>\n            <polygon class=\"up\" stroke=\"none\" fill-rule=\"evenodd\" points=\"7 15 12 10 17 15\"></polygon>\n          </svg>\n        </slot>\n      </span>\n     `;\n  }\n\n  private renderLabel() {\n    // need to render &nbsp; so that line-height can apply and give it a\n    // non-zero height\n    return html`<div id=\"label\">${this.displayText || html`&nbsp;`}</div>`;\n  }\n\n  private renderMenu() {\n    const ariaLabel = this.label || (this as ARIAMixinStrict).ariaLabel;\n    return html`\n      <md-menu\n          id=\"listbox\"\n          default-focus=\"none\"\n          role=\"listbox\"\n          tabindex=\"-1\"\n          aria-label=${ariaLabel || nothing}\n          stay-open-on-focusout\n          part=\"menu\"\n          exportparts=\"focus-ring: menu-focus-ring\"\n          anchor=\"field\"\n          .open=${this.open}\n          .quick=${this.quick}\n          .positioning=${this.menuPositioning}\n          .typeaheadDelay=${this.typeaheadDelay}\n          @opening=${this.handleOpening}\n          @opened=${this.redispatchEvent}\n          @closing=${this.redispatchEvent}\n          @closed=${this.handleClosed}\n          @close-menu=${this.handleCloseMenu}\n          @request-selection=${this.handleRequestSelection}\n          @request-deselection=${this.handleRequestDeselection}>\n        ${this.renderMenuContent()}\n      </md-menu>`;\n  }\n\n  private renderMenuContent() {\n    return html`<slot></slot>`;\n  }\n\n  /**\n   * Handles opening the select on keydown and typahead selection when the menu\n   * is closed.\n   */\n  private handleKeydown(event: KeyboardEvent) {\n    if (this.open || this.disabled || !this.menu) {\n      return;\n    }\n\n    const typeaheadController = this.menu.typeaheadController;\n    const isOpenKey = event.code === 'Space' || event.code === 'ArrowDown' ||\n        event.code === 'Enter';\n\n    // Do not open if currently typing ahead because the user may be typing the\n    // spacebar to match a word with a space\n    if (!typeaheadController.isTypingAhead && isOpenKey) {\n      event.preventDefault();\n      this.open = true;\n      return;\n    }\n\n    const isPrintableKey = event.key.length === 1;\n\n    // Handles typing ahead when the menu is closed by delegating the event to\n    // the underlying menu's typeaheadController\n    if (isPrintableKey) {\n      typeaheadController.onKeydown(event);\n      event.preventDefault();\n\n      const {lastActiveRecord} = typeaheadController;\n\n      if (!lastActiveRecord) {\n        return;\n      }\n\n      this.labelEl?.setAttribute?.('aria-live', 'polite');\n      const hasChanged = this.selectItem(\n          lastActiveRecord[TYPEAHEAD_RECORD.ITEM] as SelectOption);\n\n      if (hasChanged) {\n        this.dispatchInteractionEvents();\n      }\n    }\n  }\n\n  private handleClick() {\n    this.open = true;\n  }\n\n  private handleFocus() {\n    this.focused = true;\n  }\n\n  private handleBlur() {\n    this.focused = false;\n  }\n\n  /**\n   * Handles closing the menu when the focus leaves the select's subtree.\n   */\n  private handleFocusout(event: FocusEvent) {\n    // Don't close the menu if we are switching focus between menu,\n    // select-option, and field\n    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {\n      return;\n    }\n\n    this.open = false;\n  }\n\n  /**\n   * Gets a list of all selected select options as a list item record array.\n   *\n   * @return An array of selected list option records.\n   */\n  private getSelectedOptions() {\n    if (!this.menu) {\n      this.lastSelectedOptionRecords = [];\n      return null;\n    }\n\n    const items = this.menu.items as SelectOption[];\n    this.lastSelectedOptionRecords = getSelectedItems(items);\n    return this.lastSelectedOptionRecords;\n  }\n\n  override async getUpdateComplete() {\n    await this.menu?.updateComplete;\n    return super.getUpdateComplete();\n  }\n\n  /**\n   * Gets the selected options from the DOM, and updates the value and display\n   * text to the first selected option's value and headline respectively.\n   *\n   * @return Whether or not the selected option has changed since last update.\n   */\n  private updateValueAndDisplayText() {\n    const selectedOptions = this.getSelectedOptions() ?? [];\n    // Used to determine whether or not we need to fire an input / change event\n    // which fire whenever the option element changes (value or selectedIndex)\n    // on user interaction.\n    let hasSelectedOptionChanged = false;\n\n    if (selectedOptions.length) {\n      const [firstSelectedOption] = selectedOptions[0];\n      hasSelectedOptionChanged =\n          this.lastSelectedOption !== firstSelectedOption;\n      this.lastSelectedOption = firstSelectedOption;\n      this[VALUE] = firstSelectedOption.value;\n      this.displayText = firstSelectedOption.displayText;\n\n    } else {\n      hasSelectedOptionChanged = this.lastSelectedOption !== null;\n      this.lastSelectedOption = null;\n      this[VALUE] = '';\n      this.displayText = '';\n    }\n\n    this.internals.setFormValue(this.value);\n    this.syncValidity();\n    return hasSelectedOptionChanged;\n  }\n\n  /**\n   * Focuses and activates the last selected item upon opening, and resets other\n   * active items.\n   */\n  private async handleOpening(e: Event) {\n    this.labelEl?.removeAttribute?.('aria-live');\n    this.redispatchEvent(e);\n\n    const items = this.menu!.items as SelectOption[];\n    const activeItem = getActiveItem(items)?.item;\n    let [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];\n\n    // This is true if the user keys through the list but clicks out of the menu\n    // thus no close-menu event is fired by an item and we can't clean up in\n    // handleCloseMenu.\n    if (activeItem && activeItem !== selectedItem) {\n      activeItem.tabIndex = -1;\n    }\n\n    // in the case that nothing is selected, focus the first item\n    selectedItem = selectedItem ?? items[0];\n\n    if (selectedItem) {\n      selectedItem.tabIndex = 0;\n      selectedItem.focus();\n    }\n  }\n\n  private redispatchEvent(e: Event) {\n    redispatchEvent(this, e);\n  }\n\n  private handleClosed(e: Event) {\n    this.open = false;\n    this.redispatchEvent(e);\n  }\n\n  /**\n   * Determines the reason for closing, and updates the UI accordingly.\n   */\n  private handleCloseMenu(event: CloseMenuEvent) {\n    const reason = event.detail.reason;\n    const item = event.detail.itemPath[0] as SelectOption;\n    this.open = false;\n    let hasChanged = false;\n\n    if (reason.kind === 'click-selection') {\n      hasChanged = this.selectItem(item);\n    } else if (reason.kind === 'keydown' && isSelectableKey(reason.key)) {\n      hasChanged = this.selectItem(item);\n    } else {\n      // This can happen on ESC being pressed\n      item.tabIndex = -1;\n      item.blur();\n    }\n\n    // Dispatch interaction events since selection has been made via keyboard\n    // or mouse.\n    if (hasChanged) {\n      this.dispatchInteractionEvents();\n    }\n  }\n\n  /**\n   * Selects a given option, deselects other options, and updates the UI.\n   *\n   * @return Whether the last selected option has changed.\n   */\n  private selectItem(item: SelectOption) {\n    this.lastSelectedOptionRecords.forEach(([option]) => {\n      if (item !== option) {\n        option.selected = false;\n      }\n    });\n    item.selected = true;\n\n    return this.updateValueAndDisplayText();\n  }\n\n  /**\n   * Handles updating selection when an option element requests selection via\n   * property / attribute change.\n   */\n  private handleRequestSelection(\n      event: ReturnType<typeof createRequestSelectionEvent>) {\n    const requestingOptionEl = event.target as SelectOption & HTMLElement;\n\n    // No-op if this item is already selected.\n    if (this.lastSelectedOptionRecords.some(\n            ([option]) => option === requestingOptionEl)) {\n      return;\n    }\n\n    this.selectItem(requestingOptionEl);\n  }\n\n  /**\n   * Handles updating selection when an option element requests deselection via\n   * property / attribute change.\n   */\n  private handleRequestDeselection(\n      event: ReturnType<typeof createRequestDeselectionEvent>) {\n    const requestingOptionEl = event.target as SelectOption & HTMLElement;\n\n    // No-op if this item is not even in the list of tracked selected items.\n    if (!this.lastSelectedOptionRecords.some(\n            ([option]) => option === requestingOptionEl)) {\n      return;\n    }\n\n    this.updateValueAndDisplayText();\n  }\n\n  /**\n   * Attempts to initialize the selected option from user-settable values like\n   * SSR, setting `value`, or `selectedIndex` at startup.\n   */\n  private initUserSelection() {\n    // User has set `.value` directly, but internals have not yet booted up.\n    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {\n      this.select(this.lastUserSetValue);\n\n      // User has set `.selectedIndex` directly, but internals have not yet\n      // booted up.\n    } else if (\n        this.lastUserSetSelectedIndex !== null &&\n        !this.lastSelectedOptionRecords.length) {\n      this.selectIndex(this.lastUserSetSelectedIndex);\n\n      // Regular boot up!\n    } else {\n      this.updateValueAndDisplayText();\n    }\n  }\n\n  private handleIconChange() {\n    this.hasLeadingIcon = this.leadingIcons.length > 0;\n  }\n\n  /**\n   * Dispatches the `input` and `change` events.\n   */\n  private dispatchInteractionEvents() {\n    this.dispatchEvent(new Event('input', {bubbles: true, composed: true}));\n    this.dispatchEvent(new Event('change', {bubbles: true}));\n  }\n\n  private getErrorText() {\n    return this.error ? this.errorText : this.nativeErrorText;\n  }\n\n  private syncValidity() {\n    const valueMissing = this.required && !this.value;\n    const customError = !!this.customValidationMessage;\n    const validationMessage = this.customValidationMessage ||\n        valueMissing && this.getRequiredValidationMessage() || '';\n\n    this.internals.setValidity({valueMissing, customError}, validationMessage);\n  }\n\n  // Returns the platform `<select>` validation message for i18n.\n  private getRequiredValidationMessage() {\n    const select = document.createElement('select');\n    select.required = true;\n    return select.validationMessage;\n  }\n\n  /** @private */\n  formResetCallback() {\n    this.reset();\n  }\n\n  /** @private */\n  formStateRestoreCallback(state: string) {\n    this.value = state;\n  }\n}\n"],
  "mappings": "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",
  "names": ["isRtl", "_a", "styles", "MdMenu", "styles", "_a", "html", "state"]
}
